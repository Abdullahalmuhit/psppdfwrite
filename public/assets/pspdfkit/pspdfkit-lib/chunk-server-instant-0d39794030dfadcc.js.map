{"version":3,"file":"pspdfkit-lib/chunk-server-instant-0d39794030dfadcc.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ClientsPresence/models/Client.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/models/ClientsPresenceState.ts","webpack://PSPDFKit/./src/lib/Timer.ts","webpack://PSPDFKit/./src/lib/WebsocketConnection/WebsocketConnection.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/utils/clients.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/ClientsPresence.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/setClientsAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/applyClientChangesAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/updateCurrentClientPresenceAction.ts","webpack://PSPDFKit/./src/lib/InstantProvider/RecordChangeRequest.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSyncState.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSync.ts","webpack://PSPDFKit/./src/lib/InstantProvider/collaboration-permissions.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantProvider.ts"],"sourcesContent":["import * as Immutable from 'immutable'\n\ninterface IClient {\n  clientId: string\n  userId: string | null\n  presenceContent: Record<string, unknown>\n}\n\nexport default class Client extends Immutable.Record<IClient>({\n  clientId: '',\n  userId: null,\n  presenceContent: {},\n}) {\n  /**\n   * Holds the client ID as a string. A unique ID is generated for every client.\n   *\n   * @member {string} clientId\n   */\n  override clientId: string\n\n  /**\n   * Holds the user ID of the client. This ID is supplied by your backend. If the value is `null`,\n   * the client does not belong to a user and thus is considered anonymous.\n   *\n   * @member {?string} userId\n   */\n  override userId: string | null\n\n  /**\n   * Holds the latest presence content a client has announced. This can be an arbitrary object.\n   *\n   * @member {Object} presenceContent\n   */\n  override presenceContent: Record<string, any>\n}\n","import { Map } from 'immutable'\nimport type Client from './Client'\nimport * as Immutable from 'immutable'\n\ninterface IClientsPresenceState {\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   *\n   * @member {string} status\n   */\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: null | Client\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   *\n   * @member {Immutable.Map.<string, Client>} presence\n   */\n  clients: Map<string, Client>\n}\n\n/**\n * ClientsPresenceState\n *\n * Describes current state of ClientsPresence\n */\n\nexport default class ClientsPresenceState extends Immutable.Record<IClientsPresenceState>({\n  status: 'offline',\n  currentClient: null,\n  clients: Map(),\n}) {}\n","export default class Timer {\n  callback: () => void\n  timerCalc: (tries: number) => number\n  timer: NodeJS.Timeout | null\n  tries: number\n\n  constructor(callback: () => void, timerCalc: (tries: number) => number) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(): void {\n    this.tries = 0\n    this.timer && clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout(): void {\n    this.timer && clearTimeout(this.timer)\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1)) as unknown as NodeJS.Timeout\n  }\n}\n","import { getEnvironment } from '@/utils/environment'\nimport { Map } from 'immutable'\nimport EventEmitter from '../EventEmitter'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Timer from '../Timer'\nimport { invariant } from '@/utils/invariant'\nimport { IObject } from '@/typings/utils'\n\nconst CLIENT_VERSION = '0.0.1'\nconst PROTOCOL_VERSION = 2\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3,\n}\nconst CLIENT_INFO = {\n  name: 'PSPDFKit-Web',\n}\n\nconst defaultReconnectTimerCalc = n => [1000, 2000][n - 1] || 5000\n/**\n * SYNCConnection\n *\n * Abstracts the web socket and the sync protocol. This class behaves like an event emitter, which\n * means that we can listen on any incoming message using the `.on('type', callback)` method.\n *\n * In case the connection gets interrupted, we try to reconnect in a specified time interval. The\n * next time a reconnect is successful, we will emit the `reconnect` event.\n *\n * A SYNCConnection will publish the following events:\n *   - `connect` when the connection was authenticated with the argument\n *     `{ userId: ?string, clientId: string }`. This will also be called when the connection was\n *     closed and we have successfully reconnected. In theory the same token could then be used to\n *     authenticated a different user.\n *   - `disconnect` when the connection was interrupted. Use this to show a disconnect message until\n *     we emit the `authenticated` action again.\n *   - `error` when we discover a non-recoverable error during the authentication flow. In this\n *     case, we will try to reconnect. This can happen when the auth token is invalid.\n *   - `record_changes` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *   - `client_presence` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *\n * @private\n */\n\nexport default class WebsocketConnection {\n  eventEmitter: EventEmitter\n  serverURL: string\n  authPayload: IObject\n  socket: WebSocket | null\n  lastRequestId: number\n  requestsWaitingForAnswers: Map<\n    number,\n    {\n      resolve: (payload: IObject) => void\n      reject: (error: Error) => void\n    }\n  >\n  reconnectTimer: Timer | null\n  clientId: string\n  userId: string | null\n\n  constructor(\n    serverURL: string,\n    authPayload: IObject,\n    {\n      reconnectTimerCalc = defaultReconnectTimerCalc,\n      enableReconnect = true,\n      events = [],\n    }: {\n      reconnectTimerCalc?: (n: number) => number\n      enableReconnect?: boolean\n      events?: Array<string>\n    } = {},\n  ) {\n    this.eventEmitter = new EventEmitter(['connect', 'disconnect', 'error'].concat(events))\n    this.serverURL = serverURL\n    this.authPayload = authPayload\n    this.socket = null\n    this.lastRequestId = 0\n    this.requestsWaitingForAnswers = Map()\n\n    if (enableReconnect) {\n      this.reconnectTimer = new Timer(() => {\n        if (this.socket) {\n          this.socket.close()\n          this.socket = null\n        }\n\n        this.connect()\n      }, reconnectTimerCalc)\n    }\n\n    this.clearAuthenticationInformation()\n  }\n\n  registerEvents(events: Array<string>): void {\n    this.eventEmitter.events.push(...events)\n  }\n\n  connect() {\n    if (this.socket) {\n      return\n    }\n\n    const socket = new WebSocket(this.serverURL)\n\n    socket.onopen = this.onOpen.bind(this)\n    socket.onmessage = this.onMessage.bind(this)\n\n    socket.onerror = () => {\n      this.socket = null\n      this.eventEmitter.emit(\n        'error',\n        `Failed to create the WebSocket connection to ${this.serverURL}. ` +\n          'Please check your firewall or proxy settings.',\n      )\n    }\n\n    this.socket = socket\n  }\n\n  /**\n   * Closes the socket permanently. This will `.reject()` all outstanding request\n   */\n  disconnect(): void {\n    if (!this.socket) {\n      return\n    }\n\n    // unbind existing closing event so we don't try to reconnect\n    this.socket.onclose = () => {}\n\n    this.socket.close()\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.eventEmitter.emit('disconnect')\n  }\n\n  /**\n   * @returns {string} The current connection state. Either `connecting`, `open`, `closing`, or\n   *          `closed`\n   */\n  get connectionState(): 'connecting' | 'open' | 'closing' | 'closed' {\n    switch (this.socket && this.socket.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n\n      case SOCKET_STATES.open:\n        return 'open'\n\n      case SOCKET_STATES.closing:\n        return 'closing'\n\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * @returns {boolean} true when the connection is authenticated\n   */\n  get isAuthenticated(): boolean {\n    return this.clientId !== ''\n  }\n\n  /**\n   * Sends data asynchronously to the server. This will generate a new request ID. Whenever the\n   * server responds, we will resolve the Promise.\n   *\n   * @param {string} action - The action you want to send\n   * @param {Object} payload - An arbitrary payload. This will be serialized as JSON\n   * @returns {Promise.<Object, PSPDFKitError>} A promise that will resolve as soon as the server responds to our request.\n   */\n  sendRequest(action: string, payload: IObject): Promise<IObject> {\n    return new Promise((resolve, reject) => {\n      if (!this.isAuthenticated || !this.socket) {\n        reject(new PSPDFKitError('Cannot send request when the connection is not authenticated'))\n\n        return\n      }\n\n      const requestId = this.nextRequestId()\n      const serializedPayload = JSON.stringify(payload)\n\n      this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.set(requestId, {\n        resolve,\n        reject,\n      })\n\n      const socket: WebSocket = this.socket\n\n      socket.send(`${requestId}:${action}:${serializedPayload}`)\n    })\n  }\n\n  // `on` and `off` will be forwarded to `this.eventEmitter`\n  on(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.on(action, callback)\n  }\n\n  off(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.off(action, callback)\n  }\n\n  /**\n   * Web socket callbacks\n   */\n\n  private onOpen() {\n    const socket = this.socket\n\n    if (socket) {\n      socket.onerror = this.onError.bind(this)\n      socket.onclose = this.onClose.bind(this)\n    }\n  }\n\n  private onMessage(message: MessageEvent) {\n    const data = message.data as string\n\n    if (this.isAuthenticated) {\n      const frame = this.parseFrame(data)\n\n      // Check whether this is a notification from the server or a response to a request\n      if (frame.requestId) {\n        const requestId = frame.requestId\n\n        invariant(\n          this.requestsWaitingForAnswers.has(requestId),\n          'Received a reply with an unknown request ID.',\n        )\n\n        const request = this.requestsWaitingForAnswers.get(requestId)\n\n        invariant(request)\n\n        switch (frame.action) {\n          case 'ok':\n            request.resolve(frame.payload)\n            break\n\n          case 'error':\n            request.reject(new PSPDFKitError(frame.payload.reason || 'Unknown error'))\n            break\n\n          default:\n            invariant(false, `${frame.action} is not a valid request reply`)\n        }\n\n        this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.delete(requestId)\n      } else {\n        if (this.eventEmitter.events.includes(frame.action)) {\n          this.eventEmitter.emit(frame.action, frame.payload)\n        }\n\n        this.log('incoming info message', frame)\n      }\n    } else {\n      const frame = this.parseUnauthenticatedFrame(data)\n\n      // When the request is not yet authenticated, we only handle `hello` and `authenticated`\n      // messages\n      switch (frame.action) {\n        case 'hello':\n          this.onHello(frame.payload)\n          break\n\n        case 'authenticated':\n          this.onAuthenticated(frame.payload)\n          break\n\n        case 'error':\n          this.eventEmitter.emit('error', frame.payload.reason || 'Unknown error')\n      }\n    }\n  }\n\n  /**\n   * When the connection is closed, we will send the `disconnect` event so the client can display\n   * an adequate message. This will start our regular reconnection timer.\n   */\n  private onClose(event: CloseEvent) {\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.eventEmitter.emit('disconnect')\n    this.log('close', event)\n  }\n\n  /**\n   * We will receive an error callback when there were problems opening the web socket. This will\n   * start our regular reconnection timer.\n   */\n  private onError(error: Event) {\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.log('error', error)\n  }\n\n  private nextRequestId(): number {\n    // We deliberately don't care about integer overflow of the request id. We will handle this in\n    // the future by reconnecting the client\n    const nextRequestId = this.lastRequestId + 1\n\n    this.lastRequestId = nextRequestId\n\n    return nextRequestId\n  }\n\n  private onHello(payload: IObject): void {\n    const socket: WebSocket = this.socket as any\n\n    if (payload.protocol_version === PROTOCOL_VERSION) {\n      const requestPayload = {\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n        auth_payload: this.authPayload,\n      }\n\n      socket.send(`hello_web:${JSON.stringify(requestPayload)}`)\n    } else {\n      const requestPayload = {\n        reason: 'protocol_mismatch',\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n      }\n\n      socket.send(`handshake_failed:${JSON.stringify(requestPayload)}`)\n      this.eventEmitter.emit('error', 'protocol_mismatch')\n    }\n  }\n\n  private onAuthenticated(payload: IObject): void {\n    invariant(payload.client_id, '`authenticated` message has no `client_id`')\n    this.clientId = payload.client_id\n    this.userId = payload.user_id || null\n    this.eventEmitter.emit('connect', {\n      clientId: this.clientId,\n      userId: this.userId,\n    })\n  }\n\n  private log(...args: Array<any>): void {\n    if (getEnvironment() === 'development') {\n      console.log('SYNCConnection', ...args) // eslint-disable-line no-console\n    }\n  }\n\n  /**\n   * When `requestId` in the response object is null, the frame is of type `info`.\n   */\n  private parseFrame(frame: string): {\n    requestId?: number | null\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(\\d+|info):([a-zA-Z-_]+):(.+)$/\n    const [, requestIdOrInfo, action, serializedPayload] = regex.exec(\n      frame.toString(),\n    ) as RegExpExecArray\n    let requestId: number | null = null\n\n    if (requestIdOrInfo !== 'info') {\n      requestId = parseInt(requestIdOrInfo)\n    }\n\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      requestId,\n      action,\n      payload,\n    }\n  }\n\n  private parseUnauthenticatedFrame(frame: string): {\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(hello|authenticated|error):(.+)$/\n\n    const [, action, serializedPayload] = regex.exec(frame.toString()) as RegExpExecArray\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      action,\n      payload,\n    }\n  }\n\n  /** @private **/\n  abortOpenRequests(): void {\n    this.requestsWaitingForAnswers.forEach(request => {\n      request.reject(new PSPDFKitError('request aborted'))\n    })\n    this.requestsWaitingForAnswers = Map()\n  }\n\n  /** @private **/\n  clearAuthenticationInformation(): void {\n    this.clientId = ''\n    this.userId = null\n  }\n}\n","import { invariant } from '@pspdfkit/shared'\nimport Client from '../models/Client'\n\n/**\n * Used to map a payload entry for a client to a `Client`\n */\nexport function clientFromPayload(payload: Record<string, any>): Client {\n  invariant(typeof payload.client_id === 'string', 'The client payload must have a `client_id`')\n  invariant(typeof payload.presence === 'object', 'The client payload must have a `presence`')\n\n  return new Client({\n    clientId: payload.client_id,\n    userId: payload.user_id,\n    presenceContent: payload.presence,\n  })\n}\n","import { Class } from 'utility-types'\nimport { List, Map } from 'immutable'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Client from './models/Client'\nimport ClientsPresenceState from './models/ClientsPresenceState'\nimport WebsocketConnection from '../WebsocketConnection/WebsocketConnection'\nimport setClientsAction from './actions/setClientsAction'\nimport applyClientChangesAction from './actions/applyClientChangesAction'\nimport updateCurrentClientPresenceAction from './actions/updateCurrentClientPresenceAction'\n\nexport default class ClientsPresence {\n  connection: WebsocketConnection\n  state: ClientsPresenceState\n  setState: (arg0: ClientsPresenceState) => void\n  connectionClass: Class<any>\n  clientUpdatesCallback: (\n    arg0: Map<string, Client>,\n    arg1: Map<string, Client>,\n    arg2: List<string>,\n  ) => void\n  shouldFireClientUpdatesCallback: boolean\n\n  /**\n   * For easier testing, we allow a custom state in the constructor.\n   */\n  constructor(\n    state: ClientsPresenceState = new ClientsPresenceState(),\n    connectionClass: Class<any> = WebsocketConnection,\n  ) {\n    this.state = state\n    this.connectionClass = connectionClass\n  }\n\n  /**\n   * This method should be called right after the constructor.\n   */\n  load(\n    serverURL: string,\n    authPayload: Record<string, any>,\n    initialPresenceContent: Record<string, any>,\n  ): Promise<ClientsPresence> {\n    return new Promise((resolve, reject) => {\n      this.setState = (newState: ClientsPresenceState): void => {\n        this.state = newState\n      }\n\n      this.connection = new this.connectionClass(serverURL, authPayload, {\n        events: ['client_presence'],\n      })\n      this.connection.on(\n        'connect',\n        // @ts-expect-error\n        (session: { clientId: string; userId?: string | null }) => {\n          const currentClient = new Client({\n            clientId: session.clientId,\n            userId: session.userId,\n            presenceContent: initialPresenceContent,\n          })\n\n          this.setState(this.state.set('status', 'online').set('currentClient', currentClient))\n          this.populateClients(initialPresenceContent)\n            .then(() => {\n              resolve(this)\n            })\n            .catch(reject)\n        },\n      )\n      this.connection.on('error', message => {\n        reject(new PSPDFKitError(message.toString()))\n      })\n      this.connection.on('client_presence', payload => this.onInfoClientPresence(payload))\n      this.connection.connect()\n    })\n  }\n\n  populateClients(presenceContent: Record<string, any>): Promise<any> {\n    return new Promise<void>((resolve, reject) => {\n      const enterZonePayload = {\n        presence: presenceContent,\n      }\n\n      this.connection\n        .sendRequest('enter_layer', enterZonePayload)\n        .then(payload => {\n          this.setState(setClientsAction(this.state, payload))\n          resolve()\n        })\n        .catch(reject)\n    })\n  }\n\n  onInfoClientPresence(payload: Record<string, any>): void {\n    this.setState(applyClientChangesAction(this.state, payload))\n\n    if (this.shouldFireClientUpdatesCallback) {\n      let entered: Map<string, Client> = Map()\n\n      if (payload.clients.entered) {\n        const enteredClientIds = payload.clients.entered.map(c => c.client_id)\n\n        entered = this.state.clients\n          .filter(client => {\n            return enteredClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let updated: Map<string, Client> = Map()\n\n      if (payload.clients.updated) {\n        const updatedClientIds = payload.clients.updated.map(c => c.client_id)\n\n        updated = this.state.clients\n          .filter(client => {\n            return updatedClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let left = List()\n\n      if (payload.clients.updated) {\n        left = List(payload.clients.left)\n      }\n\n      this.clientUpdatesCallback(entered, updated, left)\n    }\n  }\n\n  /**\n   * Close the current connection and stop reconnecting attempts.\n   *\n   * @returns {void}\n   */\n  disconnect(): void {\n    if (this.getStatus() === 'offline') {\n      return\n    }\n\n    this.setState(this.state.set('status', 'offline'))\n    this.connection.disconnect()\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not.\n   *\n   * @returns {string} A status indicating the connection status, either `offline`, `connecting`, or\n   *         `online`.\n   */\n  getStatus(): 'offline' | 'connecting' | 'online' {\n    return this.state.status\n  }\n\n  /**\n   * Information about the currently connected client.\n   *\n   * @returns {Client} An object that holds information about the currently connected client.\n   */\n  getCurrentClient(): Client {\n    return this.state.currentClient as Client\n  }\n\n  /*********************\n   * Managing Presence *\n   *********************/\n\n  /**\n   * Returns a map of all connected clients of every user that is currently present in the zone.\n   *\n   * Before this method is called the first time, we will never fire a\n   * {@link ClientsPresence#onClientUpdates} callback. The reason for this is to give you time to set\n   * your callbacks, without missing out on information.\n   *\n   * @returns {Immutable.Map.<string, Client>} List of all connected clients form all users\n   */\n  getClients(): Map<string, Client> {\n    this.shouldFireClientUpdatesCallback = true\n\n    return this.state.clients\n  }\n\n  /**\n   * Updates the presence content for the zone of the current connection. The presence content is\n   * being broadcast to all other connected clients.\n   *\n   * When the server accepts our changes, we will resolve the `Promise` with `true`. In case of any\n   * error, we will reject with `PSPDFKitError`.\n   *\n   * @param {Object} presenceContent - An arbitrary object that describes the presence content.\n   * @returns {Promise.<boolean, PSPDFKitError>} A Promise that that will resolve with `true` or reject\n   *         with a `PSPDFKitError`.\n   */\n  updatePresence(presenceContent: Record<string, any>): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (this.getStatus() !== 'online') {\n        return reject(new PSPDFKitError('ClientsPresence is not connected'))\n      }\n\n      const payload = {\n        presence: presenceContent,\n      }\n\n      this.connection.sendRequest('update_client_presence', payload).then(\n        () => {\n          this.setState(updateCurrentClientPresenceAction(this.state, presenceContent))\n          resolve(true)\n        },\n        () => {\n          reject(new PSPDFKitError('Unable to update presence'))\n        },\n      )\n    })\n  }\n\n  /**********************\n   * Presence Callbacks *\n   **********************/\n\n  /**\n   * This callback will be triggered whenever the client map will be updated. It will contain\n   * the change set of entered, updated and left clients.\n   *\n   * It will not fire without you calling {@link ClientsPresence#getClients} before.\n   *\n   * @callback clientUpdatesCallback\n   * @param {Immutable.Map.<string, Client>} entered - A map of all clients that have entered\n   *        the zone\n   * @param {Immutable.Map.<string, Client>} updated - A map of all clients that published\n   *        presence updates.\n   * @param {Immutable.List.<string>} left - A list of all clients IDs that have disconnected from\n   *        this zone.\n   */\n\n  /**\n   * Sets a new clients update callback. When a callback is already set, it will overwrite the\n   * existing one (only one callback is registered to a ClientsPresence instance at any time).\n   *\n   * This callback should be registered before you call {@link ClientsPresence#getClients}. It will only\n   * fire after {@link ClientsPresence#getClients} is called the first times.\n   *\n   * The callback can never be set to `null` because otherwise your application could miss out on\n   * updates.\n   *\n   * @throws {TypeError} when the supplied `callback` is not a function\n   * @param {clientUpdatesCallback} callback - The callback that handles the clients map updates\n   */\n  onClientUpdates(\n    callback: (\n      entered: Map<string, Client>,\n      updated: Map<string, Client>,\n      left: List<string>,\n    ) => void,\n  ) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.clientUpdatesCallback = callback\n  }\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { Map } from 'immutable'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\nimport Client from '../models/Client'\n\n/**\n * This action overwrites the current clients map with the `payload`. This is used, whenever we\n * `enter_layer`\n */\n\nexport default function setClientsAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(payload.clients, 'The payload must have a `clients` list')\n\n  return state.withMutations(mutableState => {\n    const clients = Map(\n      payload.clients\n        .map(clientPayload => clientFromPayload(clientPayload))\n        .map(c => [c.clientId, c]),\n    ).set(state.currentClient?.clientId, state.currentClient) as Map<string, Client>\n\n    mutableState.set('clients', clients)\n  })\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\n\n/**\n * This action applies the change set from the `info:client_presence` message.\n *\n * @throws {PSPDFKitError} when we detect a failed state\n */\n\nexport default function applyClientChangesAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(typeof payload.clients == 'object', 'The payload must have `clients`')\n\n  const newClients = state.clients.withMutations(mutableClients => {\n    if (payload.clients.entered) {\n      for (const clientPayload of payload.clients.entered) {\n        if (state.clients.has(clientPayload.client_id)) {\n          throw new PSPDFKitError('The client marked as entered is already known')\n        }\n\n        const client = clientFromPayload(clientPayload)\n\n        mutableClients.set(client.clientId, client)\n      }\n    }\n\n    // On updated clients, only the `presenceContent` can change\n    if (payload.clients.updated) {\n      for (const clientPayload of payload.clients.updated) {\n        invariant(\n          typeof clientPayload.client_id === 'string',\n          'The client payload must have a `client_id`',\n        )\n        invariant(\n          typeof clientPayload.presence === 'object',\n          'The client payload must have a `presence`',\n        )\n\n        const client = state.clients.get(clientPayload.client_id)\n\n        if (!client) {\n          throw new PSPDFKitError('The client marked as updated is not known')\n        }\n\n        mutableClients.set(client.clientId, client.set('presenceContent', clientPayload.presence))\n      }\n    }\n\n    if (payload.clients.left) {\n      for (const clientId of payload.clients.left) {\n        if (!state.clients.has(clientId)) {\n          throw new PSPDFKitError('The client marked as left is not known')\n        }\n\n        mutableClients.delete(clientId)\n      }\n    }\n  })\n\n  return state.set('clients', newClients)\n}\n","import type ClientsPresenceState from '../models/ClientsPresenceState'\n/**\n * This is used after a successful `update_client_presence` and will set the new `presenceContent`\n * inside the `currentClient` and the current client inside the `clients` map.\n */\n\nexport default function updateCurrentClientPresenceAction(\n  state: ClientsPresenceState,\n  presenceContent: Record<string, any>,\n): ClientsPresenceState {\n  return state\n    .setIn(['currentClient', 'presenceContent'], presenceContent)\n    .setIn(['clients', state.currentClient?.clientId, 'presenceContent'], presenceContent)\n}\n","import * as Immutable from 'immutable'\n\ninterface IRecordChangeRequest {\n  id: string | null\n  content?: Record<string, any> | null\n  attachments: Record<string, Blob> | null\n  group?: string\n  type: 'created' | 'updated' | 'deleted' | null\n  resolve: (response?: Record<string, any> | boolean | null) => void\n  reject: (error?: any) => void\n}\n\nexport default class RecordChangeRequest extends Immutable.Record<IRecordChangeRequest>({\n  content: null,\n  attachments: null,\n  id: null,\n  type: null,\n  group: undefined,\n  resolve: () => {},\n  reject: () => {},\n}) {\n  /**\n   * Holds the record ID as a string. This ID must follow the Instant spec.\n   *\n   * @member {string} id\n   */\n  override id: string\n\n  /**\n   * Holds the serialized record content.\n   *\n   * @member {?Object} content\n   */\n  override content?: Record<string, any>\n\n  /**\n   * Holds an Object where the annotations ids are mapped to the Blobs of the records attachments.\n   *\n   * @member {?Object} attachments\n   */\n  override attachments: Record<string, Blob>\n\n  /**\n   * Holds the group name of the record\n   *\n   * @type {string|void}\n   */\n  override group?: string\n\n  /**\n   * Changes can be `created` for new records, `updated` for existing\n   * records with a new content, or `deleted` for deleted records.\n   *\n   * @member {string} type\n   */\n  override type: 'created' | 'updated' | 'deleted'\n\n  /**\n   * Holds the `Promise#resolve` function for the change request\n   *\n   * @member {Function} resolve\n   */\n  override resolve: (response?: Record<string, any> | boolean | null) => void\n\n  /**\n   * Holds the `Promise#reject` function for the change request\n   *\n   * @member {Function} reject\n   */\n  override reject: (error?: any) => void\n}\n","import { List, Map, OrderedMap, Set } from 'immutable'\nimport type RecordChangeRequest from './RecordChangeRequest'\nimport type Client from '../ClientsPresence/models/Client'\nimport * as Immutable from 'immutable'\n\nexport type InstantSyncAuthPayload = {\n  auth_token: string\n}\n\ninterface IInstantSyncState {\n  requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  } | null\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: Client | null\n  localRecordsContents: OrderedMap<string, Record<string, any>>\n  localRecordsChanges: List<RecordChangeRequest>\n  stagedRecordsChanges: List<RecordChangeRequest>\n  localRecordsRev: number\n  requiredAttachmentIds: Set<string>\n  clients: Map<string, Client>\n}\n\n/**\n * InstantSyncState\n *\n * Describes current state of InstantSync\n */\n\nexport default class InstantSyncState extends Immutable.Record<IInstantSyncState>({\n  requestInfo: null,\n  status: 'offline',\n  currentClient: null,\n  localRecordsContents: OrderedMap(),\n  localRecordsChanges: List(),\n  stagedRecordsChanges: List(),\n  localRecordsRev: 0,\n  requiredAttachmentIds: Set(),\n  clients: Map(),\n}) {\n  /**\n   * Holds the endpoint URL (serverURL) and authentication token to make requests.\n   */\n  override requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   */\n  override status: 'offline' | 'connecting' | 'online'\n  override currentClient: Client\n\n  /**\n   * Holds a map of serialized object contents, which are in sync with the server and have no conflicts\n   */\n  override localRecordsContents: OrderedMap<string, Record<string, any>>\n\n  /**\n   * Holds a list for changes that have been made locally and have not yet been saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override localRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds a list for changes that have been made locally and are currently being saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override stagedRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds the latest revision of the `localRecordsContents`.\n   */\n  override localRecordsRev: number\n\n  /**\n   * All attachments ids, that need to be attached to the next request.\n   */\n  override requiredAttachmentIds: Set<string>\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   */\n  override clients: Map<string, Client>\n}\n","import { Class } from 'utility-types'\nimport { List } from 'immutable'\nimport { mergeChanges } from './utils'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport RecordChangeRequest from './RecordChangeRequest'\nimport InstantSyncCycle from './InstantSyncCycle'\nimport InstantSyncState from './InstantSyncState'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type { InstantSyncResponseChanges } from './InstantSyncCycle'\nimport type { IRecord } from './InstantProvider'\nimport { DEFAULT_LONG_POLLING_TIMEOUT } from './InstantSyncCycle'\nimport { debounceAsync } from '@/utils/debounce'\n\nexport default class InstantSync {\n  /************************\n   * Record operations\n   ************************/\n  getRecords(): List<IRecord> {\n    this._shouldFireRecordsUpdateCallback = true\n\n    return this._state.localRecordsContents\n      .map((record, id) => {\n        const { content, permissions, group } = record\n\n        return {\n          content,\n          permissions,\n          group,\n          id,\n        }\n      })\n      .toList()\n  }\n\n  createRecord(\n    id: string,\n    content: Record<string, any>,\n    attachments: Record<string, Blob>,\n    group?: string,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        attachments,\n        group,\n        type: 'created',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  updateRecord(\n    id: string,\n    content?: Record<string, any>,\n    group?: string,\n  ): Promise<Record<string, any>> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        group,\n        type: 'updated',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  deleteRecord(id: string): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        type: 'deleted',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  onRecordsUpdates(\n    recordsUpdateCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n    acceptedRecordsCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n  ) {\n    if (typeof recordsUpdateCallback !== 'function') {\n      throw new TypeError('recordsUpdateCallback must be a function')\n    }\n\n    if (typeof acceptedRecordsCallback !== 'function') {\n      throw new TypeError('acceptedRecordsCallback must be a function')\n    }\n\n    this._recordsUpdatesCallback = recordsUpdateCallback\n    this._acceptedRecordsResponseCallback = acceptedRecordsCallback\n  }\n\n  destroy() {\n    if (this._cycle) {\n      this._cycle.destroy()\n    }\n  }\n\n  /**************************\n   * Private Implementation *\n   **************************/\n  _state: InstantSyncState\n  _cycle: InstantSyncCycle\n  _CycleClass: Class<InstantSyncCycle>\n  _recordsUpdatesCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _acceptedRecordsResponseCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _shouldFireRecordsUpdateCallback = false\n\n  /**\n   * For easier testing, we allow a custom state and Cycle class in the constructor.\n   */\n  constructor(\n    state: InstantSyncState = new InstantSyncState(),\n    CycleClass: Class<InstantSyncCycle> = InstantSyncCycle,\n  ) {\n    this._state = state\n    this._CycleClass = CycleClass\n  }\n\n  /**\n   * This method should be called right after the constructor. See {@link InstantSync.load} for the\n   * public abstraction.\n   */\n  load(\n    serverURL: string,\n    authPayload: InstantSyncAuthPayload,\n    listenToServerChangesEnabled = true,\n  ): Promise<InstantSync> {\n    return new Promise((resolve, reject) => {\n      const getState = () => this._state\n\n      const setState = this.setState.bind(this)\n\n      this.setState(\n        this._state.set('requestInfo', {\n          serverURL,\n          authPayload,\n        }),\n      )\n      this._cycle = new this._CycleClass({\n        getState,\n        setState,\n        onChanges: this.onChanges,\n        onAcceptedRecords: this.onAcceptedRecords,\n        longPollingTimeout: listenToServerChangesEnabled ? DEFAULT_LONG_POLLING_TIMEOUT : 0,\n      })\n\n      // Executing the runCycle here also means that we will do the initial synchronization\n      // with the server and fetch the records.\n      this._cycle // We force a timeout of `0` here since we don't want the initial loading to have a delay\n        .nextCycle(0)\n        .then(() => {\n          resolve(this)\n        })\n        .catch(reject)\n    })\n  }\n\n  setState(newState: InstantSyncState): void {\n    this._state = newState\n  }\n\n  onChanges = (changes: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = changes\n\n      this._recordsUpdatesCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  onAcceptedRecords = (accepted: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = accepted\n\n      this._acceptedRecordsResponseCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  setOnDocumentHandleConflictCallback = (callback: () => void): void => {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this._cycle.setOnDocumentHandleConflictCallback(callback)\n  }\n\n  enqueueChangeRequest(changeRequest: RecordChangeRequest): void {\n    const mergedRecordsChanges = mergeChanges({\n      oldChanges: this._state.localRecordsChanges,\n      newChanges: List([changeRequest]),\n    })\n\n    this.setState(this._state.set('localRecordsChanges', mergedRecordsChanges))\n  }\n\n  /**\n   * Performs next sync cycle, pushing `localRecordsChanges` and pulling remote changes.\n   */\n  syncChanges: () => Promise<void> = debounceAsync(() => this._cycle.nextCycle())\n\n  isKnownRecordId(id: string): boolean {\n    function createdChangeWithSameId(change: RecordChangeRequest): boolean {\n      return change.type === 'created' && change.id === id\n    }\n\n    const isSyncedRecord = this._state.localRecordsContents.has(id)\n\n    const isLocalRecord = !!this._state.localRecordsChanges.find(createdChangeWithSameId)\n    const isStagedRecord = !!this._state.stagedRecordsChanges.find(createdChangeWithSameId)\n\n    return isSyncedRecord || isLocalRecord || isStagedRecord\n  }\n}\n","import { Annotation, Comment, FormField } from '../../models'\nimport type { State } from '../../models'\nimport type { IRecord } from './InstantProvider'\n\nexport function getRecordInState(\n  state: State,\n  record: IRecord,\n): Annotation | Comment | FormField | string | undefined {\n  const existingAnnotations = state.get('annotations')\n  const existingFormFields = state.get('formFields')\n  const existingComments = state.get('comments')\n  const existingFormFieldValues = state.get('formattedFormFieldValues')\n  let formFieldName\n\n  if (record.id.startsWith('form-field-value/')) {\n    formFieldName = record.id.split('/')[1]\n  }\n\n  return (\n    existingAnnotations.get(record.id) ||\n    existingFormFields.find(value => value.id === record.id) ||\n    existingComments.get(record.id) ||\n    (formFieldName ? existingFormFieldValues.get(formFieldName) : undefined)\n  )\n}\n\nexport function isRecordInState(state: State, record: IRecord): boolean {\n  return Boolean(getRecordInState(state, record))\n}\n","import { Class } from 'utility-types'\nimport { List, Map, Set } from 'immutable'\nimport { error, warn, PSPDFKitError, info, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  isBookmarkJSON,\n  isFormFieldJSON,\n  isFormFieldValueJSON,\n  serializeAnnotation,\n  attachmentsToObject,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeFormField,\n  serializeComment,\n  isCommentJSON,\n  deserializeComment,\n  isSignatureInfoJSON,\n  isEmbeddedFileJSON,\n} from '../serializers/utils'\nimport {\n  toJSON as serializeBookmark,\n  fromJSON as deserializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { CREATE_REASON_LOAD, CREATE_REASON_NEW } from '../Provider'\nimport ClientsPresence from '../ClientsPresence/ClientsPresence'\nimport InstantSync from './InstantSync'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { isRecordInState } from './collaboration-permissions'\nimport Annotation from '@/models/annotations/Annotation'\nimport Comment from '@/models/comments/Comment'\nimport FormField from '@/models/form-fields/FormField'\nimport { getRecordInState } from './collaboration-permissions'\nimport {\n  getCollaborationPermissionsFromJSON,\n  validateCollaborationPermissionJSON,\n} from '../serializers/collaboration-permissions'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { CreateReason } from '../Provider'\nimport { Attachment, Bookmark, WidgetAnnotation } from '@/models'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport { FormFieldValue, SignatureFormField } from '@/models/form-fields'\nimport type { FormFieldProvider, FormFieldProviderCallbacks } from '../FormFieldProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as AnnotationID } from '@/models/annotations/Annotation'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { ID as CommentID } from '@/models/comments/Comment'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type Client from '../ClientsPresence/models/Client'\nimport type { InstantID } from '@/models/InstantID'\nimport type { CommentProvider, CommentProviderCallbacks } from '../CommentProvider'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { State } from '@/models'\nimport { shouldShowSignatureFields } from '@/utils/permissions'\nimport { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\n\nexport type IRecord = {\n  id: string\n  content?: Record<string, any> | null\n  group?: string | null | undefined\n  permissions?: {\n    edit: boolean\n    delete: boolean\n    view: boolean\n    setGroup: boolean\n  }\n}\n\n/**\n * InstantProvider is an implementation of the AnnotationProvider that,\n * using the `/sync` endpoint, allows the client to sync with other devices and\n * benefit from server side conflict resolution.\n *\n * `createAnnotation` and `updateAnnotation` perform optimistic updates which are reverted\n * in case of conflicts with newer updates coming from the server.\n * `deleteAnnotation` instead is signed off only after the server has accepted the change\n * since in this case roll back and restore the annotation would be harder.\n */\nexport class InstantProvider\n  implements\n    ReadStateProvider,\n    AnnotationProvider,\n    BookmarkProvider,\n    FormFieldProvider,\n    FormFieldValueProvider,\n    CommentProvider\n{\n  _readStateCallbacks?: ReadStateProviderCallbacks\n  _annotationCallbacks?: AnnotationProviderCallbacks\n  _bookmarkCallbacks?: BookmarkProviderCallbacks\n  _formFieldCallbacks?: FormFieldProviderCallbacks\n  _formFieldValueCallbacks?: FormFieldValueCallbacks\n  _commentCallbacks?: CommentProviderCallbacks\n  // We keep track of the bookmarks IDs when we create new bookmarks\n  // because Instant sends a List of IDs when some deletion occurred.\n  // In such cases we can use this list to determine whether we are dealing with\n  // a bookmarks or annotation deletion.\n  _existingBookmarksIds: Set<BookmarkID> = Set()\n  _existingFormFieldsIds: Set<AnnotationID> = Set()\n  _existingFormFieldValuesIds: Set<string> = Set()\n  _existingCommentIds: Set<InstantID> = Set()\n  _sync: InstantSync\n  _clients?: ClientsPresence\n  _documentURL: string\n  _serverURL: string\n  _settings: InstantSettings\n  _authPayload: InstantSyncAuthPayload\n  _hasLoadedInitialRecords: boolean\n  _loadPromise: Promise<void> | null | undefined\n  _getState: () => State\n  _formsEnabledInConfig: boolean\n  onClientsChangeCallback: (...args: Array<any>) => any\n  _documentHandleConflictCallback: () => void = () => {}\n  _setDocumentHandleOutdatedCallback: (arg0: boolean) => void\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    documentURL: string,\n    authPayload: InstantSyncAuthPayload,\n    settings: InstantSettings = defaultInstantSettings,\n  ) {\n    this._serverURL = serverURL\n    this._documentURL = documentURL\n    this._authPayload = authPayload\n    this._settings = settings\n    this._hasLoadedInitialRecords = false\n  }\n\n  load(\n    SyncClass: Class<InstantSync> = InstantSync,\n    ClientsPresenceClass: Class<ClientsPresence> = ClientsPresence,\n  ): Promise<InstantProvider> {\n    const initializationPromises: Promise<any>[] = []\n\n    // Initialize sync.\n    this._sync = new SyncClass()\n    initializationPromises.push(\n      this._sync\n        .load(\n          `${this._documentURL}/sync`,\n          this._authPayload,\n          this._settings.listenToServerChangesEnabled,\n        )\n        .catch(error),\n    )\n\n    this._sync.setOnDocumentHandleConflictCallback(this.onDocumentHandleConflict)\n\n    if (this._settings.clientsPresenceEnabled) {\n      // Initialize clients presence.\n      this._clients = new ClientsPresenceClass()\n      initializationPromises.push(\n        this._clients\n          .load(`${this._serverURL.replace(/^http/i, 'ws')}/websocket`, this._authPayload, {})\n          .then(() => {\n            const clients = this._clients\n\n            if (clients == null) return\n\n            // Register callback\n            clients.onClientUpdates(() => this._onClientsChange(clients.getClients()))\n\n            // Handle initial clients the same way as a clients updates callback\n            this._onClientsChange(clients.getClients())\n          })\n          .catch(error => {\n            warn(\n              'PSPDFKit: An error occurred while initializing the connected clients module. ' +\n                'This might be due to a lack of support for WebSockets or a related failure.\\n\\n' +\n                'Failure details:\\n\\n' +\n                error.message,\n            )\n          }),\n      )\n    }\n\n    return Promise.all(initializationPromises)\n      .then(() => {\n        return this\n      })\n      .catch(error => {\n        throw new PSPDFKitError(`Initialization of PSPDFKit Instant failed:\n${error.message}`)\n      })\n  }\n\n  destroy() {\n    if (this._sync) {\n      this._sync.destroy()\n    }\n  }\n\n  setFormsEnabledInConfig(formsEnabledInConfig: boolean) {\n    this._formsEnabledInConfig = formsEnabledInConfig\n  }\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this._annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this._bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldCallbacks(formFieldCallbacks: FormFieldProviderCallbacks) {\n    this._formFieldCallbacks = formFieldCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this._formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  setCommentCallbacks(commentCallbacks: CommentProviderCallbacks) {\n    this._commentCallbacks = commentCallbacks\n  }\n\n  createAnnotation(annotation: Annotation, attachments: Map<string, Attachment>): Promise<void> {\n    const { id, ...data } = serializeAnnotation(annotation)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    return this._sync.createRecord(id, content, attachmentsToObject(attachments), group)\n  }\n\n  createComment(comment: Comment): Promise<void> {\n    const { id, ...data } = serializeComment(comment)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingCommentIds = this._existingCommentIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateComment(comment: Comment): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeComment(comment))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteComment(commentId: InstantID): Promise<void> {\n    this._existingCommentIds = this._existingCommentIds.delete(commentId)\n\n    return this._sync.deleteRecord(commentId).then(() => {})\n  }\n\n  setStateGetter(getState: () => State): void {\n    this._getState = getState\n  }\n\n  async updateRecord(data: Record<string, any>): Promise<Record<string, any>> {\n    const { id, permissions, group, ...content } = data\n\n    if (\n      this._getState &&\n      this._getState() &&\n      this._getState().backend?.isCollaborationPermissionsEnabled()\n    ) {\n      return this._sync.updateRecord(\n        id,\n        permissions.edit ? content : undefined,\n        permissions.setGroup ? group : undefined,\n      )\n    } else {\n      return this._sync.updateRecord(id, content, group)\n    }\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeAnnotation(annotation))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteAnnotation(annotation: Annotation): Promise<void> {\n    return this._sync.deleteRecord(annotation.id).then(() => {})\n  }\n\n  createBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(id, content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    return this._sync.deleteRecord(bookmarkId).then(() => {\n      this._existingBookmarksIds = this._existingBookmarksIds.delete(bookmarkId)\n    })\n  }\n\n  createFormField(formField: FormField): Promise<void> {\n    const { id, ...data } = serializeFormField(formField)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateFormField(formField: FormField): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeFormField(formField))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormField(formField: FormField): Promise<void> {\n    return this._sync.deleteRecord(formField.id).then(() => {\n      this._existingFormFieldsIds = this._existingFormFieldsIds.delete(formField.id)\n    })\n  }\n\n  // Form fields are retrieved in the annotations list\n  loadFormFields(): Promise<void> {\n    return this.loadAnnotationsForPageIndex()\n  }\n\n  createFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n    const id = getFormFieldValueID(formFieldValue)\n\n    this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(getFormFieldValueID(formFieldValue), content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormFieldValue(id: string): Promise<void> {\n    return this._sync.deleteRecord(id).then(() => {\n      this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n    })\n  }\n\n  loadAnnotationsForPageIndex(): Promise<void> {\n    // We only ever start listening to real time changes and emit events when\n    // the first page loading was initiated. This will make the behavior of the\n    // Instant annotation provider similar to what we do on the others (where we\n    // do not pre-download all annotations). This is necessary because we might\n    // not handle some callbacks before that.\n    //\n    // This also has impact on JavaScript support. We now load form fields the\n    // same way as annotations when the form designer feature is present which\n    // means form fields will not be present until the first pages have been\n    // loaded. JavaScript however might interpret document level scripts before\n    // that which will cause warnings when form fields are not initialized. See\n    // comment in connect.js before calling applyJavaScriptActionChanges.\n    //\n    // @FIXME(philipp): We need to clean that up and find a way to avoid the\n    // push to the next macro queue.\n    if (this._loadPromise) {\n      return this._loadPromise\n    }\n\n    this._loadPromise = new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n      if (!this._hasLoadedInitialRecords) {\n        // Register callback\n        this._sync.onRecordsUpdates(\n          // @ts-expect-error\n\n          (c, u, d) => this._onRecordsUpdates(c, u, d, CREATE_REASON_NEW),\n          // @ts-expect-error\n          (c, u, d) => this._onAcceptedRecords(c, u, d),\n        )\n\n        // Handle initial annotations list the same way as an annotations updates callback\n        this._onRecordsUpdates(this._sync.getRecords(), List(), List(), CREATE_REASON_LOAD)\n\n        this._hasLoadedInitialRecords = true\n      }\n    })\n\n    return this._loadPromise\n  }\n\n  async loadBookmarks(): Promise<void> {\n    return\n  }\n\n  syncChanges(): Promise<void> {\n    return this._sync.syncChanges()\n  }\n\n  /**\n   * In a situation where the user has set `disableForms: true` in the configuration,\n   * we don't set `this._formFieldCallbacks` and `this._formsEnabledInConfig` is set to `false` but the server doesn't know that and keeps\n   * sending the record updates for widgets. In that case we need to filter and remove\n   * the record that are widgets if `this.__formsEnabledInConfig` is set to `false`.\n   * @param records\n   * @private\n   */\n  _filterRecords(records: List<IRecord>): List<IRecord> {\n    // @ts-expect-error\n    return records.filter(({ content }) => this._formsEnabledInConfig || !isFormFieldJSON(content))\n  }\n\n  /******************************\n   * Internal Callback Handlers *\n   ******************************/\n  _onRecordsUpdates(\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n    createReason: CreateReason,\n  ) {\n    let mutableBookmarkAdditions: List<Bookmark> = List()\n    const mutableFormFieldAdditions: Array<FormField> = []\n    let mutableFormFieldValueAdditions: List<FormFieldValue> = List()\n    let mutableCommentAdditions: List<Comment> = List()\n    let deletions = Set() // we also remove updated annotations that encountered an error during deserializing\n\n    let bookmarkDeletions = Set() // we also remove updated bookmarks that encountered an error during deserializing\n\n    let formFieldDeletions = Set() // we also remove updated form fields that encountered an error during deserializing\n\n    let formFieldValueDeletions = Set() // we also remove updated form field values that encountered an error during deserializing\n\n    let commentDeletions = Set()\n    const state = this._getState ? this._getState() : undefined\n    let _created = created\n    let _updated = updated\n    let _deleted = deleted\n\n    if (state && state.backend && state.backend.isCollaborationPermissionsEnabled()) {\n      _created = _created.filter(({ content }) => !!content)\n\n      const updatesIndexToBeRemoved: number[] = []\n\n      updated.forEach((record, index) => {\n        if (!record.content) {\n          if (isRecordInState(state, record)) {\n            // If we receive a record with no content and it’s present in our store,\n            // it means it’s visibility permission was set to hidden and\n            // we delete the record from our store.\n            _deleted = _deleted.push(record.id)\n            updatesIndexToBeRemoved.push(index)\n          } else {\n            // If we receive a record with no content and it’s not present in our store, we do nothing.\n            updatesIndexToBeRemoved.push(index)\n          }\n        } else if (!isRecordInState(state, record)) {\n          // If we receive a record with content which isn’t present in our store, it means the visibility permission was changed.\n          // In that case, we will create a new record.\n          _created = _created.push(record)\n          updatesIndexToBeRemoved.push(index)\n        }\n      })\n      _updated = _updated.filter((_record, index) => !updatesIndexToBeRemoved.includes(index))\n      _deleted = _deleted.filter(\n        d =>\n          state.annotations.has(d) ||\n          this._existingFormFieldValuesIds.has(d) ||\n          this._existingFormFieldsIds.has(d) ||\n          this._existingCommentIds.has(d) ||\n          this._existingBookmarksIds.has(d),\n      )\n    }\n\n    let additions = List().withMutations(mutableAdditions => {\n      this._filterRecords(_created).forEach(({ id, content, permissions, group }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            // @ts-expect-error\n            mutableFormFieldAdditions.push(deserializeFormField(id, content, options))\n            this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.push(\n              // @ts-expect-error\n              deserializeFormFieldValue(content),\n            )\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            // TODO figure out why when I use mutableBookmarkAdditions asMutable() push produces a list of IDs only 🤷‍♂️\n            mutableBookmarkAdditions = mutableBookmarkAdditions.push(\n              // @ts-expect-error\n              deserializeBookmark(id, content),\n            )\n            this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            this._existingCommentIds = this._existingCommentIds.add(id)\n            mutableCommentAdditions = mutableCommentAdditions.push(\n              // @ts-expect-error\n              deserializeComment(id, content, options),\n            )\n            // @ts-expect-error\n          } else if (isSignatureInfoJSON(content)) {\n            // No-op on digital signatures changes since we won't be syncing signatures\n            // on real-time\n            // @ts-expect-error\n          } else if (isEmbeddedFileJSON(content)) {\n            // No-op since web does not support embedded files yet.\n          } else {\n            // @ts-expect-error\n            mutableAdditions.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          info(\n            `Skipped creating record #${id} from payload because an error occurred while deserializing.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n    const showSignatures = state\n      ? shouldShowSignatureFields(\n          state.features,\n          state.signatureFeatureAvailability as ISignatureFeatureAvailability,\n        )\n      : true\n\n    if (mutableFormFieldAdditions.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      if (state && !showSignatures) {\n        // Although Server returns all form fields, if the needed license features\n        // combination is not given, we should avoid to add signature form fields.\n        // See https://docs.google.com/document/d/1ry0uJIGAgUPa6cmjCWCKRC5zReqdfpROuQyhOt7GXNs/edit#heading=h.dlbwh9b87wv3\n        this._formFieldCallbacks.createFormFields(\n          List(\n            mutableFormFieldAdditions.filter(\n              formField => !(formField instanceof SignatureFormField),\n            ),\n          ),\n          createReason,\n        )\n      } else {\n        this._formFieldCallbacks.createFormFields(List(mutableFormFieldAdditions), createReason)\n      }\n    }\n\n    if (additions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      if (state && !showSignatures) {\n        // Don't store widgets associated to ignored form fields on step above\n        additions = additions.filter(annotation => {\n          if (!(annotation instanceof WidgetAnnotation)) {\n            return annotation\n          }\n\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === annotation.formFieldName) ||\n            state.formFields.get(annotation.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._annotationCallbacks.createAnnotations(additions, Map(), createReason)\n    }\n\n    if (mutableFormFieldValueAdditions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      if (state && !showSignatures) {\n        // Take into account purposefully ignored form fields from step above\n        mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.filter(value => {\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === value.name) ||\n            // @ts-expect-error\n            state.formFields.get(value.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._formFieldValueCallbacks.createFormFieldValues(\n        List(mutableFormFieldValueAdditions),\n        createReason,\n      )\n    }\n\n    if (mutableCommentAdditions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.createComments(mutableCommentAdditions, createReason)\n    }\n\n    if (mutableBookmarkAdditions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.createBookmarks(mutableBookmarkAdditions, createReason)\n    }\n\n    const mutableBookmarkChanges: List<Bookmark> = List().asMutable()\n    const mutableFormFieldChanges: Array<FormField> = []\n    const mutableFormFieldValueChanges: Array<FormFieldValue> = []\n    const mutableCommentChanges: Array<Comment> = []\n    const updates = List().withMutations(mutableUpdates => {\n      this._filterRecords(_updated).forEach(({ id, content, group, permissions }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldChanges.push(deserializeFormField(id, content, options))\n            } catch (error) {\n              formFieldDeletions = formFieldDeletions.add(id)\n              info(\n                `Skipped updating form field #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldValueChanges.push(deserializeFormFieldValue(content))\n            } catch (error) {\n              formFieldValueDeletions = formFieldValueDeletions.add(id)\n              info(\n                `Skipped updating form field value #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableBookmarkChanges.push(deserializeBookmark(id, content))\n            } catch (error) {\n              bookmarkDeletions = bookmarkDeletions.add(id)\n              info(\n                `Skipped updating bookmark #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableCommentChanges.push(deserializeComment(id, content, options))\n            } catch (error) {\n              commentDeletions = commentDeletions.add(id)\n              info(\n                `Skipped updating comment #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n                error,\n              )\n            }\n          } else {\n            // @ts-expect-error\n            mutableUpdates.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          deletions = deletions.add(id)\n          info(\n            `Skipped updating annotation #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n\n    if (updates.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.updateAnnotations(updates)\n    }\n\n    if (mutableBookmarkChanges.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.updateBookmarks(mutableBookmarkChanges)\n    }\n\n    if (mutableFormFieldChanges.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(mutableFormFieldChanges))\n    }\n\n    if (mutableFormFieldValueChanges.length > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.setFormFieldValues(List(mutableFormFieldValueChanges))\n    }\n\n    if (mutableCommentChanges.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(mutableCommentChanges))\n    }\n\n    deletions = deletions.concat(\n      _deleted\n        .filter(\n          id =>\n            !this._existingBookmarksIds.has(id) &&\n            !this._existingFormFieldsIds.has(id) &&\n            !this._existingFormFieldValuesIds.has(id) &&\n            !this._existingCommentIds.has(id),\n        )\n        .toSet(),\n    )\n\n    if (deletions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.deleteAnnotations(deletions)\n    }\n\n    bookmarkDeletions = bookmarkDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isBookmarkDeletion = this._existingBookmarksIds.has(id)\n\n          if (isBookmarkDeletion) {\n            this._existingBookmarksIds = this._existingBookmarksIds.delete(id)\n          }\n\n          return isBookmarkDeletion\n        })\n        .toSet(),\n    )\n\n    if (bookmarkDeletions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.deleteBookmarks(bookmarkDeletions)\n    }\n\n    formFieldDeletions = formFieldDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldDeletion = this._existingFormFieldsIds.has(id)\n\n          if (isFormFieldDeletion) {\n            this._existingFormFieldsIds = this._existingFormFieldsIds.delete(id)\n          }\n\n          return isFormFieldDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldDeletions.size > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(formFieldDeletions)\n    }\n\n    formFieldValueDeletions = formFieldValueDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldValueDeletion = this._existingFormFieldValuesIds.has(id)\n\n          if (isFormFieldValueDeletion) {\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n          }\n\n          return isFormFieldValueDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldValueDeletions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.deleteFormFieldValues(formFieldValueDeletions)\n    }\n\n    commentDeletions = commentDeletions.concat(\n      _deleted\n        .filter(id => {\n          const commentDeletion = this._existingCommentIds.has(id)\n\n          if (commentDeletion) {\n            this._existingCommentIds = this._existingCommentIds.delete(id)\n          }\n\n          return commentDeletion\n        })\n        .toSet(),\n    )\n\n    if (commentDeletions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(commentDeletions)\n    }\n  }\n\n  _onAcceptedRecords(created: List<IRecord>, updated: List<IRecord>) {\n    const state = this._getState ? this._getState() : undefined\n\n    if (!state || !state.backend || !state.backend.isCollaborationPermissionsEnabled()) {\n      return\n    }\n\n    // When Collaboration Permissions are enabled we need to update the locally created or updated\n    // records so that they include the proper permissions enforced by the backend.\n    const annotationsUpdates: Array<Annotation> = []\n    const commentsUpdates: Array<Comment> = []\n    const formFieldsUpdates: Array<FormField> = []\n    // We also need to remove records from the Redux store if Server doesn't assign view\n    // permissions\n    const deletableAnnotations: Array<AnnotationID> = []\n    const deletableComments: Array<BookmarkID> = []\n    const deletableFormFields: Array<CommentID> = []\n\n    if (!created.isEmpty()) {\n      created.forEach(mergePermissionsOnRecords)\n    }\n\n    if (!updated.isEmpty()) {\n      updated.forEach(mergePermissionsOnRecords)\n    }\n\n    if (annotationsUpdates.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.updateAnnotations(List(annotationsUpdates), true)\n    }\n\n    if (commentsUpdates.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(commentsUpdates))\n    }\n\n    if (formFieldsUpdates.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(formFieldsUpdates))\n    }\n\n    if (deletableAnnotations.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.deleteAnnotations(Set(deletableAnnotations), true)\n    }\n\n    if (deletableComments.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(Set(deletableComments))\n    }\n\n    if (deletableFormFields.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(Set(deletableFormFields))\n    }\n\n    function mergePermissionsOnRecords(record: IRecord) {\n      const options = {\n        permissions: record.permissions,\n        group: record.group,\n      }\n      let entity = getRecordInState(state as State, record)\n\n      // We can ignore form field values responses (string type)\n      if (entity && typeof entity !== 'string') {\n        validateCollaborationPermissionJSON(options)\n\n        const collaborationPermissions = getCollaborationPermissionsFromJSON(options)\n\n        entity = entity.merge(collaborationPermissions)\n\n        if (entity instanceof Annotation) {\n          if (options.permissions && options.permissions.view) {\n            annotationsUpdates.push(entity)\n          } else {\n            deletableAnnotations.push(entity.id)\n          }\n        } else if (entity instanceof Comment) {\n          if (options.permissions && options.permissions.view) {\n            commentsUpdates.push(entity)\n          } else {\n            invariant(entity.id)\n            deletableComments.push(entity.id)\n          }\n        } else if (entity instanceof FormField) {\n          if (options.permissions && options.permissions.view) {\n            formFieldsUpdates.push(entity)\n          } else {\n            deletableFormFields.push(entity.id)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the on clients change callback. Will be overwritten when another callback is set.\n   */\n  onClientsChange(onClientsChangeCallback: (clients: Map<string, Client>) => void): void {\n    if (typeof onClientsChangeCallback !== 'function') {\n      throw new TypeError('Callback must be a function')\n    }\n\n    this.onClientsChangeCallback = onClientsChangeCallback\n  }\n\n  _onClientsChange(clients: Map<string, Client>): void {\n    this.onClientsChangeCallback.call(null, clients)\n  }\n\n  /**\n   * Document handle conflict callback handlers.\n   */\n\n  /**\n   * Set by ServerBackend after instantiating the provider\n   */\n  setDocumentHandleConflictCallback = (callback: () => void) => {\n    this._documentHandleConflictCallback = callback\n  }\n\n  /**\n   * Set in utils/document by setupManagers() on connect and reconnect\n   */\n  setDocumentHandleOutdated = (callback: (arg0: boolean) => void) => {\n    this._setDocumentHandleOutdatedCallback = callback\n  }\n\n  /**\n   * Callback passed to InstantSync when instantiating it\n   */\n  onDocumentHandleConflict = () => {\n    this._documentHandleConflictCallback && this._documentHandleConflictCallback()\n    this._setDocumentHandleOutdatedCallback && this._setDocumentHandleOutdatedCallback(true)\n  }\n}\n"],"names":["Client","Immutable","clientId","userId","presenceContent","ClientsPresenceState","status","currentClient","clients","Map","Timer","callback","timerCalc","this","timer","tries","clearTimeout","setTimeout","CLIENT_VERSION","SOCKET_STATES","CLIENT_INFO","name","defaultReconnectTimerCalc","n","WebsocketConnection","serverURL","authPayload","reconnectTimerCalc","enableReconnect","events","eventEmitter","EventEmitter","concat","socket","lastRequestId","requestsWaitingForAnswers","reconnectTimer","close","connect","clearAuthenticationInformation","push","WebSocket","onopen","onOpen","bind","onmessage","onMessage","onerror","emit","onclose","abortOpenRequests","readyState","action","payload","Promise","resolve","reject","isAuthenticated","requestId","nextRequestId","serializedPayload","JSON","stringify","set","send","PSPDFKitError","on","off","onError","onClose","message","data","frame","parseFrame","invariant","has","request","get","reason","delete","includes","log","parseUnauthenticatedFrame","onHello","onAuthenticated","event","scheduleTimeout","error","protocol_version","requestPayload","client_version","client_info","auth_payload","client_id","user_id","getEnvironment","args","console","exec","toString","requestIdOrInfo","parseInt","parse","forEach","clientFromPayload","presence","ClientsPresence","state","connectionClass","initialPresenceContent","setState","newState","connection","session","populateClients","then","catch","onInfoClientPresence","sendRequest","withMutations","mutableState","map","clientPayload","c","setClientsAction","newClients","mutableClients","entered","client","updated","left","applyClientChangesAction","shouldFireClientUpdatesCallback","enteredClientIds","filter","indexOf","toMap","updatedClientIds","List","clientUpdatesCallback","getStatus","disconnect","setIn","updateCurrentClientPresenceAction","TypeError","RecordChangeRequest","content","attachments","id","type","group","undefined","InstantSyncState","requestInfo","localRecordsContents","OrderedMap","localRecordsChanges","stagedRecordsChanges","localRecordsRev","requiredAttachmentIds","Set","InstantSync","CycleClass","InstantSyncCycle","changes","_shouldFireRecordsUpdateCallback","created","deleted","_recordsUpdatesCallback","accepted","_acceptedRecordsResponseCallback","_cycle","setOnDocumentHandleConflictCallback","debounceAsync","nextCycle","_state","_CycleClass","record","permissions","toList","change","enqueueChangeRequest","isKnownRecordId","recordsUpdateCallback","acceptedRecordsCallback","destroy","listenToServerChangesEnabled","getState","onChanges","onAcceptedRecords","longPollingTimeout","DEFAULT_LONG_POLLING_TIMEOUT","changeRequest","mergedRecordsChanges","mergeChanges","oldChanges","newChanges","createdChangeWithSameId","isSyncedRecord","isLocalRecord","find","isStagedRecord","getRecordInState","formFieldName","existingAnnotations","existingFormFields","existingComments","existingFormFieldValues","startsWith","split","value","isRecordInState","Boolean","InstantProvider","documentURL","settings","defaultInstantSettings","_documentHandleConflictCallback","_setDocumentHandleOutdatedCallback","_serverURL","_documentURL","_authPayload","_settings","_hasLoadedInitialRecords","SyncClass","ClientsPresenceClass","initializationPromises","_sync","load","onDocumentHandleConflict","clientsPresenceEnabled","_clients","replace","onClientUpdates","_onClientsChange","getClients","warn","all","formsEnabledInConfig","_formsEnabledInConfig","readStateCallbacks","_readStateCallbacks","annotationCallbacks","_annotationCallbacks","bookmarkCallbacks","_bookmarkCallbacks","formFieldCallbacks","_formFieldCallbacks","formFieldValueCallbacks","_formFieldValueCallbacks","commentCallbacks","_commentCallbacks","annotation","serializeAnnotation","createRecord","attachmentsToObject","comment","serializeComment","_existingCommentIds","add","updateRecord","commentId","deleteRecord","_getState","backend","isCollaborationPermissionsEnabled","edit","setGroup","bookmark","serializeBookmark","_existingBookmarksIds","bookmarkId","formField","serializeFormField","_existingFormFieldsIds","loadAnnotationsForPageIndex","formFieldValue","serializeFormFieldValue","getFormFieldValueID","_existingFormFieldValuesIds","_loadPromise","onRecordsUpdates","u","d","_onRecordsUpdates","CREATE_REASON_NEW","_onAcceptedRecords","getRecords","CREATE_REASON_LOAD","syncChanges","records","isFormFieldJSON","createReason","mutableBookmarkAdditions","mutableFormFieldAdditions","mutableFormFieldValueAdditions","mutableCommentAdditions","deletions","bookmarkDeletions","formFieldDeletions","formFieldValueDeletions","commentDeletions","_created","_updated","_deleted","updatesIndexToBeRemoved","index","_record","annotations","additions","mutableAdditions","_filterRecords","options","deserializeFormField","isFormFieldValueJSON","deserializeFormFieldValue","isBookmarkJSON","deserializeBookmark","isCommentJSON","deserializeComment","isSignatureInfoJSON","isEmbeddedFileJSON","deserializeAnnotation","info","showSignatures","shouldShowSignatureFields","features","signatureFeatureAvailability","length","createFormFields","SignatureFormField","size","WidgetAnnotation","field","formFields","createAnnotations","createFormFieldValues","createComments","createBookmarks","mutableBookmarkChanges","asMutable","mutableFormFieldChanges","mutableFormFieldValueChanges","mutableCommentChanges","updates","mutableUpdates","updateAnnotations","updateBookmarks","updateFormFields","setFormFieldValues","updateComments","toSet","deleteAnnotations","isBookmarkDeletion","deleteBookmarks","isFormFieldDeletion","deleteFormFields","isFormFieldValueDeletion","deleteFormFieldValues","commentDeletion","deleteComments","annotationsUpdates","commentsUpdates","formFieldsUpdates","deletableAnnotations","deletableComments","deletableFormFields","isEmpty","mergePermissionsOnRecords","entity","validateCollaborationPermissionJSON","collaborationPermissions","getCollaborationPermissionsFromJSON","merge","Annotation","view","Comment","FormField","onClientsChangeCallback","call"],"sourceRoot":""}