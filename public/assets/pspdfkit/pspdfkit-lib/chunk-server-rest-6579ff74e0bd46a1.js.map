{"version":3,"file":"pspdfkit-lib/chunk-server-rest-6579ff74e0bd46a1.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/RESTProvider/RESTProviderState.ts","webpack://PSPDFKit/./src/lib/RESTProvider/RESTProvider.ts"],"sourcesContent":["import { List, Map } from 'immutable'\nimport * as Immutable from 'immutable'\n\ninterface IRESTProviderState {\n  alreadyLoadedPages: Map<number, Promise<void>>\n  serverURL: string | null\n  authPayload: {\n    token: string\n  } | null\n  isLoaded: boolean\n  isFormsEnabled: boolean\n  loadBookmarksPromise: Promise<void> | null | undefined\n  ignoredFormFieldNames?: List<string> | null\n}\n\nexport class RESTProviderState extends Immutable.Record<IRESTProviderState>({\n  alreadyLoadedPages: Map(),\n  serverURL: null,\n  authPayload: null,\n  isLoaded: false,\n  isFormsEnabled: true,\n  loadBookmarksPromise: null,\n  ignoredFormFieldNames: null,\n}) {\n  /**\n   * Used to remember which page annotations have already been loaded.\n   *\n   * @member {Immutable.Map.<number, Promise.<void>>} alreadyLoadedPages\n   */\n  override alreadyLoadedPages: Map<number, Promise<void>>\n\n  /**\n   * @member {string} serverURL\n   */\n  override serverURL: string\n\n  /**\n   * @member {Object} authPayload\n   */\n  override authPayload: {\n    token: string\n  }\n  override isLoaded: boolean\n  override isFormsEnabled: boolean\n\n  /**\n   * Used to fire loadBookmarks only once.\n   *\n   * @member {?Promise.<void>} loadBookmarksPromise\n   */\n  override loadBookmarksPromise: Promise<void> | null | undefined\n\n  /**\n   * Used to know which form field values can be omitted safely.\n   *\n   * @member {?List.<string>} ignoredFormFieldNames\n   */\n  override ignoredFormFieldNames?: List<string>\n}\n","import { List, Map } from 'immutable'\nimport { info, PSPDFKitError, error } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  serializeAnnotation,\n  serializeFormFieldValue,\n} from '../serializers/utils'\nimport {\n  fromJSON as deserializeBookmark,\n  toJSON as serializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { RESTProviderState } from './RESTProviderState'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { CREATE_REASON_LOAD } from '../Provider'\nimport type { Annotation, Attachment, Bookmark, FormFieldValue } from '../../models'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as BookmarkID } from '../../models/Bookmark'\nimport { invariant } from '../../utils/invariant'\nimport { IObject } from '../../typings/utils'\nimport { getVersionHeader } from '@/utils/environment'\n\n/**\n * A REST interface to annotation loading. It can't handle real time update and will fetch\n * annotations per-page.\n *\n * @todo How do we handle errors?\n */\nexport class RESTProvider\n  implements ReadStateProvider, AnnotationProvider, BookmarkProvider, FormFieldValueProvider\n{\n  _readStateCallbacks: ReadStateProviderCallbacks | null | undefined\n  annotationCallbacks: AnnotationProviderCallbacks | null | undefined\n  bookmarkCallbacks: BookmarkProviderCallbacks | null | undefined\n  formFieldValueCallbacks: FormFieldValueCallbacks | null | undefined\n  state: RESTProviderState\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    authPayload: {\n      token: string\n    },\n    {\n      isFormsEnabled,\n    }: {\n      isFormsEnabled: boolean\n    },\n  ) {\n    this.state = new RESTProviderState({\n      serverURL,\n      authPayload,\n      isFormsEnabled,\n    })\n  }\n\n  /*************************\n   * Connection management *\n   *************************/\n  async load(): Promise<RESTProvider> {\n    this.state = this.state.set('isLoaded', true)\n\n    if (this.state.isFormsEnabled) {\n      // Form Field Values are not loaded on a per-page basis. Thus, we fetch them all in here\n      await this._initializeFormFieldValues()\n    }\n\n    return this\n  }\n\n  destroy(): void {}\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this.annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this.bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this.formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  /******************\n   * Annotation API *\n   ******************/\n  async createAnnotation(\n    annotation: Annotation,\n    attachments: Map<string, Attachment>,\n  ): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n    const annotationBody = {\n      id,\n      content,\n    }\n\n    await this._request('/annotations', 'POST', annotationBody).then(r => {\n      if (r.status !== 200) {\n        throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an annotation.')\n      }\n\n      r.json().then(json => {\n        if (json.error === 'attachment_missing') {\n          // When the attachment is not already stored on the server, we need to attach the\n          // attachments to the request\n          const newBody = createFormData(annotationBody, attachments)\n\n          return this._request('/annotations', 'POST', newBody).then(r => r.json())\n        }\n\n        return json\n      })\n    })\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    await this._request(`/annotations/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    await this._request(`/annotations/${annotation.id}`, 'DELETE')\n  }\n\n  /******************\n   * Bookmark API *\n   ******************/\n  async createBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n    const response = await this._request('/bookmarks', 'POST', {\n      id,\n      content,\n    })\n\n    if (response.status !== 200) {\n      throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an bookmark.')\n    }\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    await this._request(`/bookmarks/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n    await this._request(`/bookmarks/${bookmarkId}`, 'DELETE')\n  }\n\n  /******************\n   * FormFieldValue API *\n   ******************/\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    this._verifyLoaded()\n\n    const payload = {\n      id: getFormFieldValueID(formFieldValue),\n      content: serializeFormFieldValue(formFieldValue),\n    }\n\n    await this._request('/form-field-values', 'POST', {\n      formFieldValues: [payload],\n    })\n  }\n\n  // Stub to be implemented when this provider is supported\n  async createFormFieldValue(): Promise<void> {\n    return\n  }\n\n  // Stub to be implemented when this provider is supported\n  async deleteFormFieldValue(): Promise<void> {\n    return\n  }\n\n  async loadAnnotationsForPageIndex(pageIndex: number): Promise<void> {\n    this._verifyLoaded()\n\n    if (this.state.alreadyLoadedPages.has(pageIndex)) {\n      await this.state.alreadyLoadedPages.get(pageIndex)\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request(`/page-${pageIndex}-annotations`, 'GET')\n        .then(response => response.json())\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadAnnotationsForPageIndex` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], Promise.resolve())\n\n      const additions = List().withMutations(mutableAdditions => {\n        payload.annotations.forEach(record => {\n          try {\n            mutableAdditions.push(deserializeAnnotation(record.id, record.content))\n          } catch (error) {\n            info(\n              `Skipped creating annotation #${record.id} from payload because an error occurred while deserializing.`,\n              record.content,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (additions.size > 0) {\n        invariant(this.annotationCallbacks)\n        this.annotationCallbacks.createAnnotations(additions, Map(), CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'annotations')\n    }\n  }\n\n  async loadBookmarks() {\n    this._verifyLoaded()\n\n    if (this.state.loadBookmarksPromise) {\n      await this.state.loadBookmarksPromise\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request('/bookmarks', 'GET')\n        .then(response => response.json())\n        .then(payload => payload.data)\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadBookmarks` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.set('loadBookmarksPromise', payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.set('loadBookmarksPromise', Promise.resolve())\n      invariant(Array.isArray(payload.bookmarks), 'Unexpected reply from bookmarks endpoint.')\n\n      const bookmarks = List().withMutations(mutableBookmarks => {\n        payload.bookmarks.forEach((json: Record<string, any>) => {\n          try {\n            mutableBookmarks.push(deserializeBookmark(json.id, json.content))\n          } catch (error) {\n            info(\n              `Skipped creating bookmark #${json.id} from payload because an error occurred while deserializing.`,\n              // @ts-expect-error\n              json,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (bookmarks.size > 0) {\n        invariant(this.bookmarkCallbacks)\n        this.bookmarkCallbacks.createBookmarks(bookmarks, CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'bookmarks')\n    }\n  }\n\n  async syncChanges(): Promise<void> {}\n\n  async _initializeFormFieldValues(): Promise<void> {\n    const request = await this._request('/form-field-values', 'GET')\n    const response = await request.json()\n\n    invariant(\n      Array.isArray(response.formFieldValues),\n      'Unexpected reply from form-values endpoint.',\n    )\n\n    const formFieldValues = List<FormFieldValue>(\n      response.formFieldValues\n        .map(({ content: formFieldValueJSON }) => {\n          try {\n            return deserializeFormFieldValue(formFieldValueJSON)\n          } catch (error) {\n            info(\n              `Skipped form field value ${formFieldValueJSON.name} from payload because an error occurred while deserializing.`,\n              formFieldValueJSON,\n            )\n            info(error)\n\n            return null\n          }\n        })\n        .filter(Boolean),\n    )\n\n    invariant(this.formFieldValueCallbacks)\n\n    if (this.state.ignoredFormFieldNames && this.state.ignoredFormFieldNames.size) {\n      this.formFieldValueCallbacks.setFormFieldValues(\n        formFieldValues.filter(value => !this.state.ignoredFormFieldNames?.includes(value.name)),\n      )\n    } else {\n      this.formFieldValueCallbacks.setFormFieldValues(formFieldValues)\n    }\n  }\n\n  _handleError(e: Error, type: 'annotations' | 'bookmarks') {\n    error(`Loading or updating ${type} failed:\n\n${e.message}`)\n  }\n\n  _request(\n    path: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    body?: IObject,\n  ): Promise<IObject> {\n    invariant(this.state.authPayload != null, 'Cannot call request without authPayload')\n\n    const contentTypeHeader =\n      !(body instanceof FormData) && typeof body === 'object'\n        ? {\n            'Content-Type': 'application/json',\n          }\n        : null\n    const headers = {\n      'X-PSPDFKit-Token': this.state.authPayload.token,\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n      ...contentTypeHeader,\n    }\n\n    return fetch(`${this.state.serverURL}${path}`, {\n      method,\n      headers,\n      body:\n        body instanceof FormData\n          ? body\n          : typeof body === 'object'\n          ? JSON.stringify(body)\n          : undefined,\n      credentials: 'include',\n    })\n  }\n\n  _verifyLoaded() {\n    if (!this.state.isLoaded) {\n      throw new Error('not loaded')\n    }\n  }\n\n  setDocumentHandleConflictCallback = () => {}\n\n  setIgnoredFormFieldNames(formFields: List<string>) {\n    this.state = this.state.set('ignoredFormFieldNames', formFields)\n  }\n}\n\nfunction createFormData(annotationBody, attachments) {\n  const formData = new FormData()\n\n  formData.append('annotation', JSON.stringify(annotationBody))\n  attachments.forEach((attachment, attachmentId) => {\n    if (attachmentId && attachment.data) {\n      formData.append(attachmentId, attachment.data)\n    }\n  })\n\n  return formData\n}\n"],"names":["RESTProviderState","Immutable","alreadyLoadedPages","Map","serverURL","authPayload","isLoaded","isFormsEnabled","loadBookmarksPromise","ignoredFormFieldNames","RESTProvider","this","state","set","_initializeFormFieldValues","readStateCallbacks","_readStateCallbacks","annotationCallbacks","bookmarkCallbacks","formFieldValueCallbacks","annotation","attachments","_verifyLoaded","serializeAnnotation","id","content","annotationBody","_request","then","r","status","PSPDFKitError","json","error","newBody","createFormData","bookmark","loadBookmarks","serializeBookmark","bookmarkId","formFieldValue","payload","getFormFieldValueID","serializeFormFieldValue","formFieldValues","pageIndex","has","get","payloadPromise","response","catch","setIn","Promise","resolve","additions","List","withMutations","mutableAdditions","annotations","forEach","record","push","deserializeAnnotation","info","size","invariant","createAnnotations","CREATE_REASON_LOAD","_handleError","data","Array","isArray","bookmarks","mutableBookmarks","deserializeBookmark","createBookmarks","request","map","formFieldValueJSON","deserializeFormFieldValue","name","filter","Boolean","setFormFieldValues","value","includes","e","type","message","path","method","body","contentTypeHeader","FormData","headers","token","getVersionHeader","fetch","JSON","stringify","undefined","credentials","Error","formFields","formData","append","attachment","attachmentId"],"sourceRoot":""}