{"version":3,"file":"pspdfkit-lib/chunk-standalone-9a522560ca97e581.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/StandaloneBackend/StandaloneBackendWASM.ts"],"sourcesContent":["import { $Call } from 'utility-types'\nimport { getBaseUrl } from '@/utils/environment'\nimport { List } from 'immutable'\nimport { PSPDFKitError, error, invariant } from '@pspdfkit/shared'\nimport StandaloneBackend from './StandaloneBackend'\nimport type { LoadOptions } from '@/typings/backend'\nimport type { StandaloneConfiguration } from '@/Configuration'\nimport type { Core, FetchedCustomFont } from '@/core/CoreTypes'\nimport { getElectronAppId } from '@/core/electron'\nimport { Options } from '@/constants/config'\nimport { base64EncodeCertificate } from '@/utils/digitalSignatures'\nimport { mergeActionChangesWithFormattingActionChanges } from '@/utils/forms'\nimport { normalizeCoreOptions } from './StandaloneBackend'\nimport type Font from '@/models/Font'\nimport { SignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\nimport { LicenseFeatures } from '@/models'\nimport { ActionChange } from '@/models/actions/Action'\n\nlet previousLicenseKey\n\nexport {\n  corePool,\n  validateStandaloneConfiguration,\n  normalizeCoreOptions,\n} from './StandaloneBackend'\n\nconst progressIncrement = 0.3\n\nexport default class StandaloneBackendWASM extends StandaloneBackend {\n  destroyed: boolean\n\n  constructor(configuration: StandaloneConfiguration) {\n    const baseUrl = configuration.baseUrl || getBaseUrl(window.document)\n    const configWithBaseUrl = { ...configuration, baseUrl }\n\n    if (typeof configWithBaseUrl.baseUrl !== 'string') {\n      throw new PSPDFKitError(\n        '`baseUrl` is mandatory and must be a valid URL, e.g. `https://example.com/`',\n      )\n    }\n\n    // Validate document\n    if (\n      typeof configWithBaseUrl.document !== 'string' &&\n      !(configWithBaseUrl.document instanceof ArrayBuffer)\n    ) {\n      throw new PSPDFKitError(\n        'document must be either an URL to a supported document type (PDF and images), e.g. `https://example.com/document.pdf`, or an `ArrayBuffer`',\n      )\n    }\n\n    // Validate licenseKey\n    if (previousLicenseKey && previousLicenseKey !== configWithBaseUrl.licenseKey) {\n      throw new PSPDFKitError(\n        `Trying to re-use PSPDFKit for Web with a different licenseKey than the previous one.\nUnfortunately we only allow one licenseKey per instance.\nPlease contact support for further assistance.`,\n      )\n    } else if (\n      typeof configWithBaseUrl.licenseKey === 'string' &&\n      configWithBaseUrl.licenseKey.startsWith('TRIAL-')\n    ) {\n      throw new PSPDFKitError(`You're using the npm key instead of the license key. This key is used to download the PSPDFKit for Web package via the node package manager.\n\nLeave out the license key to activate as a trial.`)\n    }\n\n    super(configWithBaseUrl)\n    this.destroyed = false\n  }\n\n  // @ts-expect-error\n  async load(options: LoadOptions = {}) {\n    let documentBufferPromise\n    let progressToReport = 0.2\n\n    options.progressCallback && options.progressCallback('loading', progressToReport)\n\n    if (typeof this._state.document === 'string') {\n      documentBufferPromise = fetch(this._state.document, {\n        credentials: 'same-origin',\n      })\n        .then(d => d.arrayBuffer())\n        .finally(() => {\n          progressToReport += progressIncrement\n          options.progressCallback && options.progressCallback('loading', progressToReport)\n        })\n    } else {\n      documentBufferPromise = this._state.document\n    }\n\n    const res = await loadModule(this.client, this._state).finally(() => {\n      progressToReport += progressIncrement\n      options.progressCallback && options.progressCallback('loading', progressToReport)\n    })\n\n    invariant(res)\n\n    const { features, signatureFeatureAvailability } = res\n\n    const finalSignatureFeatureAvailability =\n      signatureFeatureAvailability === SignatureFeatureAvailability.ELECTRONIC_SIGNATURES &&\n      features.includes(LicenseFeatures.WEB_ANNOTATION_EDITING) &&\n      this._state.forceLegacySignaturesFeature\n        ? SignatureFeatureAvailability.LEGACY_SIGNATURES\n        : signatureFeatureAvailability\n\n    this._state = this._state\n      .set('features', List(features))\n      .set('signatureFeatureAvailability', finalSignatureFeatureAvailability)\n\n    previousLicenseKey = this._state.licenseKey\n\n    const documentBuffer = await documentBufferPromise\n    let documentResponse\n\n    try {\n      if (this.destroyed) {\n        // Unloading an instance that didn't finish loading and then loading\n        // a new one could lead to an edge race condition if the current\n        // StandaloneBackendWASM instance gets destroyed while the previous load() call\n        // didn't get to open the document yet. Since the underlying CoreClient instance\n        // is recycled between instances of StandaloneBackendWASM, the call to\n        // this.client.openDocument() would set the _hasOpenedDocument flag to true,\n        // and the new StandaloneBackendWASM instance attempt to load the same\n        // CoreClient instance would fail because of the initial invariant check to\n        // prevent calling load() on the same CoreClient twice.\n        // So, at this point if a call to destroy() on this instance was made,\n        // we can await to a promise that will never fulfill and avoid the rest\n        // of this method being added to the task queue.\n        documentResponse = await new Promise(() => {})\n      } else {\n        documentResponse = await this.client.openDocument(documentBuffer, options.password)\n      }\n    } catch (error) {\n      // When we get an INVALID_PASSWORD error, the PDF is transferred back to the main thread\n      // and we need to save it again in the state.\n      if (error.message === 'INVALID_PASSWORD' && this._state.document instanceof ArrayBuffer) {\n        this._state = this._state.set('document', error.callArgs[0])\n      }\n\n      if (error.message === 'IMAGE_DOCUMENTS_NOT_LICENSED') {\n        error.message =\n          'The image documents feature is not enabled for your license key. Please contact support or sales to purchase the UI module for PSPDFKit for Web.'\n      }\n\n      throw error\n    }\n\n    if (this._XFDF) {\n      await this.client.importXFDF(this._XFDF.source, this._XFDF.keepCurrentAnnotations)\n    }\n\n    let jsActionChanges: ActionChange[] = []\n\n    if (Options.PDF_JAVASCRIPT) {\n      const initialChanges = await this.client.enablePDFJavaScriptSupport()\n      const formattingChanges = await this.client.runPDFFormattingScripts()\n\n      jsActionChanges = mergeActionChangesWithFormattingActionChanges(\n        initialChanges,\n        formattingChanges,\n      )\n    }\n\n    // If the backend was instantiated with an instant JSON, we need to verify that the\n    // pdfId if present\n    if (this._instantJSON && this._instantJSON.pdfId && documentResponse.ID.permanent) {\n      const expectedIds = this._instantJSON.pdfId\n      const actualIds = documentResponse.ID\n\n      if (expectedIds.permanent !== actualIds.permanent) {\n        throw new PSPDFKitError(`Could not instantiate from Instant JSON: Permanent PDF ID mismatch.\nPlease use the same PDF document that was used to create this Instant JSON.\nFor more information, please visit: https://pspdfkit.com/guides/web/current/importing-exporting/instant-json/`)\n      }\n\n      if (expectedIds.changing !== actualIds.changing) {\n        throw new PSPDFKitError(`Could not instantiate from Instant JSON: Changing PDF ID mismatch.\nPlease use the same revision of this PDF document that was used to create this Instant JSON.\nFor more information, please visit: https://pspdfkit.com/guides/web/current/importing-exporting/instant-json/`)\n      }\n    }\n\n    if (this._trustedCAsCallback) {\n      try {\n        const certificates = await this._trustedCAsCallback()\n\n        if (!Array.isArray(certificates)) {\n          throw new PSPDFKitError('Certificates response must be an array')\n        }\n\n        if (certificates.some(cert => !(cert instanceof ArrayBuffer) && typeof cert !== 'string')) {\n          throw new PSPDFKitError(\n            'All certificates must be passed as ArrayBuffer (DER) or string (PEM)',\n          )\n        }\n\n        await this.client.loadCertificates(certificates.map(base64EncodeCertificate))\n      } catch (e) {\n        throw new PSPDFKitError(\n          `Could not retrieve certificates for digital signatures validation: ${e.message}.`,\n        )\n      }\n    }\n\n    // We should then set them in the StandaloneBackendState and return them in this method as a list.\n    this._state = this._state.set('documentResponse', documentResponse)\n\n    return {\n      features: this._state.features,\n      signatureFeatureAvailability: this._state.signatureFeatureAvailability,\n      hasPassword: !!options.password,\n      allowedTileScales: 'all',\n      jsActionChanges,\n    }\n  }\n\n  override destroy(): void {\n    this.destroyed = true\n    super.destroy()\n  }\n}\n\nfunction retrieveCustomFonts(customFonts: Array<Font>) {\n  // Not using Promise.allSettled to avoid a new polyfill just for this case\n  return Promise.all(\n    customFonts.map(\n      font =>\n        new Promise<void | FetchedCustomFont>(resolve => {\n          invariant(font.name)\n\n          font\n            ?.callback?.(font.name)\n            .then(blob => {\n              invariant(font.name)\n\n              if (blob instanceof Blob) {\n                resolve({\n                  name: font.name,\n                  data: blob,\n                })\n              } else {\n                error(\n                  `Callback for retrieving font ${\n                    font.name\n                  } didn't returned a Blob. It returned ${typeof blob}`,\n                )\n                // Promise.all requires all promises to be fulfilled.\n                // We need to filter this out after resolving\n                resolve()\n              }\n            })\n            .catch(err => {\n              error(`Error returned by callback for retrieving font ${font.name}. ${err}`)\n              // Promise.all requires all promises to be fulfilled\n              // We need to filter this out after resolving\n              resolve()\n            })\n        }),\n    ),\n  ).then(results => results.filter(Boolean))\n}\n\n// Exported to reset on tests\nexport const customFontsPromiseRef: {\n  current: Promise<Array<FetchedCustomFont>> | null | undefined\n} = {\n  current: undefined,\n}\n\nexport function loadModule(client: Core, config: $Call<typeof normalizeCoreOptions>) {\n  customFontsPromiseRef.current =\n    customFontsPromiseRef.current ||\n    (config.customFonts\n      ? (retrieveCustomFonts(config.customFonts) as Promise<Array<FetchedCustomFont>>)\n      : undefined)\n\n  const mainThreadOrigin = config.electronAppName || getElectronAppId() || window.location.origin\n\n  return client\n    .loadNativeModule(config.baseUrl, {\n      mainThreadOrigin,\n      disableWebAssembly: config.disableWebAssembly,\n      disableWebAssemblyStreaming: config.disableWebAssemblyStreaming,\n      enableAutomaticLinkExtraction: config.enableAutomaticLinkExtraction,\n      overrideMemoryLimit: config.overrideMemoryLimit,\n    })\n    .then(async () => {\n      return customFontsPromiseRef.current\n        ? client.load(config.baseUrl, config.licenseKey, {\n            mainThreadOrigin,\n            customFonts: await customFontsPromiseRef.current,\n          })\n        : client.load(config.baseUrl, config.licenseKey, {\n            mainThreadOrigin,\n          })\n    })\n}\n"],"names":["previousLicenseKey","progressIncrement","StandaloneBackendWASM","configuration","baseUrl","getBaseUrl","window","document","configWithBaseUrl","PSPDFKitError","ArrayBuffer","licenseKey","startsWith","destroyed","options","progressToReport","progressCallback","documentBufferPromise","this","_state","fetch","credentials","then","d","arrayBuffer","finally","loadModule","client","res","invariant","features","signatureFeatureAvailability","finalSignatureFeatureAvailability","SignatureFeatureAvailability","includes","LicenseFeatures","forceLegacySignaturesFeature","set","List","documentBuffer","Promise","documentResponse","openDocument","password","message","callArgs","_XFDF","importXFDF","source","keepCurrentAnnotations","jsActionChanges","Options","enablePDFJavaScriptSupport","initialChanges","runPDFFormattingScripts","formattingChanges","mergeActionChangesWithFormattingActionChanges","_instantJSON","pdfId","ID","permanent","expectedIds","actualIds","changing","_trustedCAsCallback","certificates","Array","isArray","some","cert","loadCertificates","map","base64EncodeCertificate","hasPassword","allowedTileScales","StandaloneBackend","customFontsPromiseRef","current","undefined","config","customFonts","all","font","resolve","name","callback","blob","Blob","data","error","catch","err","results","filter","Boolean","mainThreadOrigin","electronAppName","getElectronAppId","location","origin","loadNativeModule","disableWebAssembly","disableWebAssemblyStreaming","enableAutomaticLinkExtraction","overrideMemoryLimit","load"],"sourceRoot":""}