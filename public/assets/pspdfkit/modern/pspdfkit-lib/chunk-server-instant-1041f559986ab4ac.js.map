{"version":3,"file":"modern/pspdfkit-lib/chunk-server-instant-1041f559986ab4ac.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ClientsPresence/models/Client.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/models/ClientsPresenceState.ts","webpack://PSPDFKit/./src/lib/Timer.ts","webpack://PSPDFKit/./src/lib/WebsocketConnection/WebsocketConnection.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/utils/clients.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/ClientsPresence.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/setClientsAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/applyClientChangesAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/updateCurrentClientPresenceAction.ts","webpack://PSPDFKit/./src/lib/InstantProvider/RecordChangeRequest.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSyncState.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSync.ts","webpack://PSPDFKit/./src/lib/InstantProvider/collaboration-permissions.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantProvider.ts"],"sourcesContent":["import * as Immutable from 'immutable'\n\ninterface IClient {\n  clientId: string\n  userId: string | null\n  presenceContent: Record<string, unknown>\n}\n\nexport default class Client extends Immutable.Record<IClient>({\n  clientId: '',\n  userId: null,\n  presenceContent: {},\n}) {\n  /**\n   * Holds the client ID as a string. A unique ID is generated for every client.\n   *\n   * @member {string} clientId\n   */\n  override clientId: string\n\n  /**\n   * Holds the user ID of the client. This ID is supplied by your backend. If the value is `null`,\n   * the client does not belong to a user and thus is considered anonymous.\n   *\n   * @member {?string} userId\n   */\n  override userId: string | null\n\n  /**\n   * Holds the latest presence content a client has announced. This can be an arbitrary object.\n   *\n   * @member {Object} presenceContent\n   */\n  override presenceContent: Record<string, any>\n}\n","import { Map } from 'immutable'\nimport type Client from './Client'\nimport * as Immutable from 'immutable'\n\ninterface IClientsPresenceState {\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   *\n   * @member {string} status\n   */\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: null | Client\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   *\n   * @member {Immutable.Map.<string, Client>} presence\n   */\n  clients: Map<string, Client>\n}\n\n/**\n * ClientsPresenceState\n *\n * Describes current state of ClientsPresence\n */\n\nexport default class ClientsPresenceState extends Immutable.Record<IClientsPresenceState>({\n  status: 'offline',\n  currentClient: null,\n  clients: Map(),\n}) {}\n","export default class Timer {\n  callback: () => void\n  timerCalc: (tries: number) => number\n  timer: NodeJS.Timeout | null\n  tries: number\n\n  constructor(callback: () => void, timerCalc: (tries: number) => number) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(): void {\n    this.tries = 0\n    this.timer && clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout(): void {\n    this.timer && clearTimeout(this.timer)\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1)) as unknown as NodeJS.Timeout\n  }\n}\n","import { getEnvironment } from '@/utils/environment'\nimport { Map } from 'immutable'\nimport EventEmitter from '../EventEmitter'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Timer from '../Timer'\nimport { invariant } from '@/utils/invariant'\nimport { IObject } from '@/typings/utils'\n\nconst CLIENT_VERSION = '0.0.1'\nconst PROTOCOL_VERSION = 2\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3,\n}\nconst CLIENT_INFO = {\n  name: 'PSPDFKit-Web',\n}\n\nconst defaultReconnectTimerCalc = n => [1000, 2000][n - 1] || 5000\n/**\n * SYNCConnection\n *\n * Abstracts the web socket and the sync protocol. This class behaves like an event emitter, which\n * means that we can listen on any incoming message using the `.on('type', callback)` method.\n *\n * In case the connection gets interrupted, we try to reconnect in a specified time interval. The\n * next time a reconnect is successful, we will emit the `reconnect` event.\n *\n * A SYNCConnection will publish the following events:\n *   - `connect` when the connection was authenticated with the argument\n *     `{ userId: ?string, clientId: string }`. This will also be called when the connection was\n *     closed and we have successfully reconnected. In theory the same token could then be used to\n *     authenticated a different user.\n *   - `disconnect` when the connection was interrupted. Use this to show a disconnect message until\n *     we emit the `authenticated` action again.\n *   - `error` when we discover a non-recoverable error during the authentication flow. In this\n *     case, we will try to reconnect. This can happen when the auth token is invalid.\n *   - `record_changes` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *   - `client_presence` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *\n * @private\n */\n\nexport default class WebsocketConnection {\n  eventEmitter: EventEmitter\n  serverURL: string\n  authPayload: IObject\n  socket: WebSocket | null\n  lastRequestId: number\n  requestsWaitingForAnswers: Map<\n    number,\n    {\n      resolve: (payload: IObject) => void\n      reject: (error: Error) => void\n    }\n  >\n  reconnectTimer: Timer | null\n  clientId: string\n  userId: string | null\n\n  constructor(\n    serverURL: string,\n    authPayload: IObject,\n    {\n      reconnectTimerCalc = defaultReconnectTimerCalc,\n      enableReconnect = true,\n      events = [],\n    }: {\n      reconnectTimerCalc?: (n: number) => number\n      enableReconnect?: boolean\n      events?: Array<string>\n    } = {},\n  ) {\n    this.eventEmitter = new EventEmitter(['connect', 'disconnect', 'error'].concat(events))\n    this.serverURL = serverURL\n    this.authPayload = authPayload\n    this.socket = null\n    this.lastRequestId = 0\n    this.requestsWaitingForAnswers = Map()\n\n    if (enableReconnect) {\n      this.reconnectTimer = new Timer(() => {\n        if (this.socket) {\n          this.socket.close()\n          this.socket = null\n        }\n\n        this.connect()\n      }, reconnectTimerCalc)\n    }\n\n    this.clearAuthenticationInformation()\n  }\n\n  registerEvents(events: Array<string>): void {\n    this.eventEmitter.events.push(...events)\n  }\n\n  connect() {\n    if (this.socket) {\n      return\n    }\n\n    const socket = new WebSocket(this.serverURL)\n\n    socket.onopen = this.onOpen.bind(this)\n    socket.onmessage = this.onMessage.bind(this)\n\n    socket.onerror = () => {\n      this.socket = null\n      this.eventEmitter.emit(\n        'error',\n        `Failed to create the WebSocket connection to ${this.serverURL}. ` +\n          'Please check your firewall or proxy settings.',\n      )\n    }\n\n    this.socket = socket\n  }\n\n  /**\n   * Closes the socket permanently. This will `.reject()` all outstanding request\n   */\n  disconnect(): void {\n    if (!this.socket) {\n      return\n    }\n\n    // unbind existing closing event so we don't try to reconnect\n    this.socket.onclose = () => {}\n\n    this.socket.close()\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.eventEmitter.emit('disconnect')\n  }\n\n  /**\n   * @returns {string} The current connection state. Either `connecting`, `open`, `closing`, or\n   *          `closed`\n   */\n  get connectionState(): 'connecting' | 'open' | 'closing' | 'closed' {\n    switch (this.socket && this.socket.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n\n      case SOCKET_STATES.open:\n        return 'open'\n\n      case SOCKET_STATES.closing:\n        return 'closing'\n\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * @returns {boolean} true when the connection is authenticated\n   */\n  get isAuthenticated(): boolean {\n    return this.clientId !== ''\n  }\n\n  /**\n   * Sends data asynchronously to the server. This will generate a new request ID. Whenever the\n   * server responds, we will resolve the Promise.\n   *\n   * @param {string} action - The action you want to send\n   * @param {Object} payload - An arbitrary payload. This will be serialized as JSON\n   * @returns {Promise.<Object, PSPDFKitError>} A promise that will resolve as soon as the server responds to our request.\n   */\n  sendRequest(action: string, payload: IObject): Promise<IObject> {\n    return new Promise((resolve, reject) => {\n      if (!this.isAuthenticated || !this.socket) {\n        reject(new PSPDFKitError('Cannot send request when the connection is not authenticated'))\n\n        return\n      }\n\n      const requestId = this.nextRequestId()\n      const serializedPayload = JSON.stringify(payload)\n\n      this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.set(requestId, {\n        resolve,\n        reject,\n      })\n\n      const socket: WebSocket = this.socket\n\n      socket.send(`${requestId}:${action}:${serializedPayload}`)\n    })\n  }\n\n  // `on` and `off` will be forwarded to `this.eventEmitter`\n  on(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.on(action, callback)\n  }\n\n  off(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.off(action, callback)\n  }\n\n  /**\n   * Web socket callbacks\n   */\n\n  private onOpen() {\n    const socket = this.socket\n\n    if (socket) {\n      socket.onerror = this.onError.bind(this)\n      socket.onclose = this.onClose.bind(this)\n    }\n  }\n\n  private onMessage(message: MessageEvent) {\n    const data = message.data as string\n\n    if (this.isAuthenticated) {\n      const frame = this.parseFrame(data)\n\n      // Check whether this is a notification from the server or a response to a request\n      if (frame.requestId) {\n        const requestId = frame.requestId\n\n        invariant(\n          this.requestsWaitingForAnswers.has(requestId),\n          'Received a reply with an unknown request ID.',\n        )\n\n        const request = this.requestsWaitingForAnswers.get(requestId)\n\n        invariant(request)\n\n        switch (frame.action) {\n          case 'ok':\n            request.resolve(frame.payload)\n            break\n\n          case 'error':\n            request.reject(new PSPDFKitError(frame.payload.reason || 'Unknown error'))\n            break\n\n          default:\n            invariant(false, `${frame.action} is not a valid request reply`)\n        }\n\n        this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.delete(requestId)\n      } else {\n        if (this.eventEmitter.events.includes(frame.action)) {\n          this.eventEmitter.emit(frame.action, frame.payload)\n        }\n\n        this.log('incoming info message', frame)\n      }\n    } else {\n      const frame = this.parseUnauthenticatedFrame(data)\n\n      // When the request is not yet authenticated, we only handle `hello` and `authenticated`\n      // messages\n      switch (frame.action) {\n        case 'hello':\n          this.onHello(frame.payload)\n          break\n\n        case 'authenticated':\n          this.onAuthenticated(frame.payload)\n          break\n\n        case 'error':\n          this.eventEmitter.emit('error', frame.payload.reason || 'Unknown error')\n      }\n    }\n  }\n\n  /**\n   * When the connection is closed, we will send the `disconnect` event so the client can display\n   * an adequate message. This will start our regular reconnection timer.\n   */\n  private onClose(event: CloseEvent) {\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.eventEmitter.emit('disconnect')\n    this.log('close', event)\n  }\n\n  /**\n   * We will receive an error callback when there were problems opening the web socket. This will\n   * start our regular reconnection timer.\n   */\n  private onError(error: Event) {\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.log('error', error)\n  }\n\n  private nextRequestId(): number {\n    // We deliberately don't care about integer overflow of the request id. We will handle this in\n    // the future by reconnecting the client\n    const nextRequestId = this.lastRequestId + 1\n\n    this.lastRequestId = nextRequestId\n\n    return nextRequestId\n  }\n\n  private onHello(payload: IObject): void {\n    const socket: WebSocket = this.socket as any\n\n    if (payload.protocol_version === PROTOCOL_VERSION) {\n      const requestPayload = {\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n        auth_payload: this.authPayload,\n      }\n\n      socket.send(`hello_web:${JSON.stringify(requestPayload)}`)\n    } else {\n      const requestPayload = {\n        reason: 'protocol_mismatch',\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n      }\n\n      socket.send(`handshake_failed:${JSON.stringify(requestPayload)}`)\n      this.eventEmitter.emit('error', 'protocol_mismatch')\n    }\n  }\n\n  private onAuthenticated(payload: IObject): void {\n    invariant(payload.client_id, '`authenticated` message has no `client_id`')\n    this.clientId = payload.client_id\n    this.userId = payload.user_id || null\n    this.eventEmitter.emit('connect', {\n      clientId: this.clientId,\n      userId: this.userId,\n    })\n  }\n\n  private log(...args: Array<any>): void {\n    if (getEnvironment() === 'development') {\n      console.log('SYNCConnection', ...args) // eslint-disable-line no-console\n    }\n  }\n\n  /**\n   * When `requestId` in the response object is null, the frame is of type `info`.\n   */\n  private parseFrame(frame: string): {\n    requestId?: number | null\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(\\d+|info):([a-zA-Z-_]+):(.+)$/\n    const [, requestIdOrInfo, action, serializedPayload] = regex.exec(\n      frame.toString(),\n    ) as RegExpExecArray\n    let requestId: number | null = null\n\n    if (requestIdOrInfo !== 'info') {\n      requestId = parseInt(requestIdOrInfo)\n    }\n\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      requestId,\n      action,\n      payload,\n    }\n  }\n\n  private parseUnauthenticatedFrame(frame: string): {\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(hello|authenticated|error):(.+)$/\n\n    const [, action, serializedPayload] = regex.exec(frame.toString()) as RegExpExecArray\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      action,\n      payload,\n    }\n  }\n\n  /** @private **/\n  abortOpenRequests(): void {\n    this.requestsWaitingForAnswers.forEach(request => {\n      request.reject(new PSPDFKitError('request aborted'))\n    })\n    this.requestsWaitingForAnswers = Map()\n  }\n\n  /** @private **/\n  clearAuthenticationInformation(): void {\n    this.clientId = ''\n    this.userId = null\n  }\n}\n","import { invariant } from '@pspdfkit/shared'\nimport Client from '../models/Client'\n\n/**\n * Used to map a payload entry for a client to a `Client`\n */\nexport function clientFromPayload(payload: Record<string, any>): Client {\n  invariant(typeof payload.client_id === 'string', 'The client payload must have a `client_id`')\n  invariant(typeof payload.presence === 'object', 'The client payload must have a `presence`')\n\n  return new Client({\n    clientId: payload.client_id,\n    userId: payload.user_id,\n    presenceContent: payload.presence,\n  })\n}\n","import { Class } from 'utility-types'\nimport { List, Map } from 'immutable'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Client from './models/Client'\nimport ClientsPresenceState from './models/ClientsPresenceState'\nimport WebsocketConnection from '../WebsocketConnection/WebsocketConnection'\nimport setClientsAction from './actions/setClientsAction'\nimport applyClientChangesAction from './actions/applyClientChangesAction'\nimport updateCurrentClientPresenceAction from './actions/updateCurrentClientPresenceAction'\n\nexport default class ClientsPresence {\n  connection: WebsocketConnection\n  state: ClientsPresenceState\n  setState: (arg0: ClientsPresenceState) => void\n  connectionClass: Class<any>\n  clientUpdatesCallback: (\n    arg0: Map<string, Client>,\n    arg1: Map<string, Client>,\n    arg2: List<string>,\n  ) => void\n  shouldFireClientUpdatesCallback: boolean\n\n  /**\n   * For easier testing, we allow a custom state in the constructor.\n   */\n  constructor(\n    state: ClientsPresenceState = new ClientsPresenceState(),\n    connectionClass: Class<any> = WebsocketConnection,\n  ) {\n    this.state = state\n    this.connectionClass = connectionClass\n  }\n\n  /**\n   * This method should be called right after the constructor.\n   */\n  load(\n    serverURL: string,\n    authPayload: Record<string, any>,\n    initialPresenceContent: Record<string, any>,\n  ): Promise<ClientsPresence> {\n    return new Promise((resolve, reject) => {\n      this.setState = (newState: ClientsPresenceState): void => {\n        this.state = newState\n      }\n\n      this.connection = new this.connectionClass(serverURL, authPayload, {\n        events: ['client_presence'],\n      })\n      this.connection.on(\n        'connect',\n        // @ts-expect-error\n        (session: { clientId: string; userId?: string | null }) => {\n          const currentClient = new Client({\n            clientId: session.clientId,\n            userId: session.userId,\n            presenceContent: initialPresenceContent,\n          })\n\n          this.setState(this.state.set('status', 'online').set('currentClient', currentClient))\n          this.populateClients(initialPresenceContent)\n            .then(() => {\n              resolve(this)\n            })\n            .catch(reject)\n        },\n      )\n      this.connection.on('error', message => {\n        reject(new PSPDFKitError(message.toString()))\n      })\n      this.connection.on('client_presence', payload => this.onInfoClientPresence(payload))\n      this.connection.connect()\n    })\n  }\n\n  populateClients(presenceContent: Record<string, any>): Promise<any> {\n    return new Promise<void>((resolve, reject) => {\n      const enterZonePayload = {\n        presence: presenceContent,\n      }\n\n      this.connection\n        .sendRequest('enter_layer', enterZonePayload)\n        .then(payload => {\n          this.setState(setClientsAction(this.state, payload))\n          resolve()\n        })\n        .catch(reject)\n    })\n  }\n\n  onInfoClientPresence(payload: Record<string, any>): void {\n    this.setState(applyClientChangesAction(this.state, payload))\n\n    if (this.shouldFireClientUpdatesCallback) {\n      let entered: Map<string, Client> = Map()\n\n      if (payload.clients.entered) {\n        const enteredClientIds = payload.clients.entered.map(c => c.client_id)\n\n        entered = this.state.clients\n          .filter(client => {\n            return enteredClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let updated: Map<string, Client> = Map()\n\n      if (payload.clients.updated) {\n        const updatedClientIds = payload.clients.updated.map(c => c.client_id)\n\n        updated = this.state.clients\n          .filter(client => {\n            return updatedClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let left = List()\n\n      if (payload.clients.updated) {\n        left = List(payload.clients.left)\n      }\n\n      this.clientUpdatesCallback(entered, updated, left)\n    }\n  }\n\n  /**\n   * Close the current connection and stop reconnecting attempts.\n   *\n   * @returns {void}\n   */\n  disconnect(): void {\n    if (this.getStatus() === 'offline') {\n      return\n    }\n\n    this.setState(this.state.set('status', 'offline'))\n    this.connection.disconnect()\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not.\n   *\n   * @returns {string} A status indicating the connection status, either `offline`, `connecting`, or\n   *         `online`.\n   */\n  getStatus(): 'offline' | 'connecting' | 'online' {\n    return this.state.status\n  }\n\n  /**\n   * Information about the currently connected client.\n   *\n   * @returns {Client} An object that holds information about the currently connected client.\n   */\n  getCurrentClient(): Client {\n    return this.state.currentClient as Client\n  }\n\n  /*********************\n   * Managing Presence *\n   *********************/\n\n  /**\n   * Returns a map of all connected clients of every user that is currently present in the zone.\n   *\n   * Before this method is called the first time, we will never fire a\n   * {@link ClientsPresence#onClientUpdates} callback. The reason for this is to give you time to set\n   * your callbacks, without missing out on information.\n   *\n   * @returns {Immutable.Map.<string, Client>} List of all connected clients form all users\n   */\n  getClients(): Map<string, Client> {\n    this.shouldFireClientUpdatesCallback = true\n\n    return this.state.clients\n  }\n\n  /**\n   * Updates the presence content for the zone of the current connection. The presence content is\n   * being broadcast to all other connected clients.\n   *\n   * When the server accepts our changes, we will resolve the `Promise` with `true`. In case of any\n   * error, we will reject with `PSPDFKitError`.\n   *\n   * @param {Object} presenceContent - An arbitrary object that describes the presence content.\n   * @returns {Promise.<boolean, PSPDFKitError>} A Promise that that will resolve with `true` or reject\n   *         with a `PSPDFKitError`.\n   */\n  updatePresence(presenceContent: Record<string, any>): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (this.getStatus() !== 'online') {\n        return reject(new PSPDFKitError('ClientsPresence is not connected'))\n      }\n\n      const payload = {\n        presence: presenceContent,\n      }\n\n      this.connection.sendRequest('update_client_presence', payload).then(\n        () => {\n          this.setState(updateCurrentClientPresenceAction(this.state, presenceContent))\n          resolve(true)\n        },\n        () => {\n          reject(new PSPDFKitError('Unable to update presence'))\n        },\n      )\n    })\n  }\n\n  /**********************\n   * Presence Callbacks *\n   **********************/\n\n  /**\n   * This callback will be triggered whenever the client map will be updated. It will contain\n   * the change set of entered, updated and left clients.\n   *\n   * It will not fire without you calling {@link ClientsPresence#getClients} before.\n   *\n   * @callback clientUpdatesCallback\n   * @param {Immutable.Map.<string, Client>} entered - A map of all clients that have entered\n   *        the zone\n   * @param {Immutable.Map.<string, Client>} updated - A map of all clients that published\n   *        presence updates.\n   * @param {Immutable.List.<string>} left - A list of all clients IDs that have disconnected from\n   *        this zone.\n   */\n\n  /**\n   * Sets a new clients update callback. When a callback is already set, it will overwrite the\n   * existing one (only one callback is registered to a ClientsPresence instance at any time).\n   *\n   * This callback should be registered before you call {@link ClientsPresence#getClients}. It will only\n   * fire after {@link ClientsPresence#getClients} is called the first times.\n   *\n   * The callback can never be set to `null` because otherwise your application could miss out on\n   * updates.\n   *\n   * @throws {TypeError} when the supplied `callback` is not a function\n   * @param {clientUpdatesCallback} callback - The callback that handles the clients map updates\n   */\n  onClientUpdates(\n    callback: (\n      entered: Map<string, Client>,\n      updated: Map<string, Client>,\n      left: List<string>,\n    ) => void,\n  ) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.clientUpdatesCallback = callback\n  }\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { Map } from 'immutable'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\nimport Client from '../models/Client'\n\n/**\n * This action overwrites the current clients map with the `payload`. This is used, whenever we\n * `enter_layer`\n */\n\nexport default function setClientsAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(payload.clients, 'The payload must have a `clients` list')\n\n  return state.withMutations(mutableState => {\n    const clients = Map(\n      payload.clients\n        .map(clientPayload => clientFromPayload(clientPayload))\n        .map(c => [c.clientId, c]),\n    ).set(state.currentClient?.clientId, state.currentClient) as Map<string, Client>\n\n    mutableState.set('clients', clients)\n  })\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\n\n/**\n * This action applies the change set from the `info:client_presence` message.\n *\n * @throws {PSPDFKitError} when we detect a failed state\n */\n\nexport default function applyClientChangesAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(typeof payload.clients == 'object', 'The payload must have `clients`')\n\n  const newClients = state.clients.withMutations(mutableClients => {\n    if (payload.clients.entered) {\n      for (const clientPayload of payload.clients.entered) {\n        if (state.clients.has(clientPayload.client_id)) {\n          throw new PSPDFKitError('The client marked as entered is already known')\n        }\n\n        const client = clientFromPayload(clientPayload)\n\n        mutableClients.set(client.clientId, client)\n      }\n    }\n\n    // On updated clients, only the `presenceContent` can change\n    if (payload.clients.updated) {\n      for (const clientPayload of payload.clients.updated) {\n        invariant(\n          typeof clientPayload.client_id === 'string',\n          'The client payload must have a `client_id`',\n        )\n        invariant(\n          typeof clientPayload.presence === 'object',\n          'The client payload must have a `presence`',\n        )\n\n        const client = state.clients.get(clientPayload.client_id)\n\n        if (!client) {\n          throw new PSPDFKitError('The client marked as updated is not known')\n        }\n\n        mutableClients.set(client.clientId, client.set('presenceContent', clientPayload.presence))\n      }\n    }\n\n    if (payload.clients.left) {\n      for (const clientId of payload.clients.left) {\n        if (!state.clients.has(clientId)) {\n          throw new PSPDFKitError('The client marked as left is not known')\n        }\n\n        mutableClients.delete(clientId)\n      }\n    }\n  })\n\n  return state.set('clients', newClients)\n}\n","import type ClientsPresenceState from '../models/ClientsPresenceState'\n/**\n * This is used after a successful `update_client_presence` and will set the new `presenceContent`\n * inside the `currentClient` and the current client inside the `clients` map.\n */\n\nexport default function updateCurrentClientPresenceAction(\n  state: ClientsPresenceState,\n  presenceContent: Record<string, any>,\n): ClientsPresenceState {\n  return state\n    .setIn(['currentClient', 'presenceContent'], presenceContent)\n    .setIn(['clients', state.currentClient?.clientId, 'presenceContent'], presenceContent)\n}\n","import * as Immutable from 'immutable'\n\ninterface IRecordChangeRequest {\n  id: string | null\n  content?: Record<string, any> | null\n  attachments: Record<string, Blob> | null\n  group?: string\n  type: 'created' | 'updated' | 'deleted' | null\n  resolve: (response?: Record<string, any> | boolean | null) => void\n  reject: (error?: any) => void\n}\n\nexport default class RecordChangeRequest extends Immutable.Record<IRecordChangeRequest>({\n  content: null,\n  attachments: null,\n  id: null,\n  type: null,\n  group: undefined,\n  resolve: () => {},\n  reject: () => {},\n}) {\n  /**\n   * Holds the record ID as a string. This ID must follow the Instant spec.\n   *\n   * @member {string} id\n   */\n  override id: string\n\n  /**\n   * Holds the serialized record content.\n   *\n   * @member {?Object} content\n   */\n  override content?: Record<string, any>\n\n  /**\n   * Holds an Object where the annotations ids are mapped to the Blobs of the records attachments.\n   *\n   * @member {?Object} attachments\n   */\n  override attachments: Record<string, Blob>\n\n  /**\n   * Holds the group name of the record\n   *\n   * @type {string|void}\n   */\n  override group?: string\n\n  /**\n   * Changes can be `created` for new records, `updated` for existing\n   * records with a new content, or `deleted` for deleted records.\n   *\n   * @member {string} type\n   */\n  override type: 'created' | 'updated' | 'deleted'\n\n  /**\n   * Holds the `Promise#resolve` function for the change request\n   *\n   * @member {Function} resolve\n   */\n  override resolve: (response?: Record<string, any> | boolean | null) => void\n\n  /**\n   * Holds the `Promise#reject` function for the change request\n   *\n   * @member {Function} reject\n   */\n  override reject: (error?: any) => void\n}\n","import { List, Map, OrderedMap, Set } from 'immutable'\nimport type RecordChangeRequest from './RecordChangeRequest'\nimport type Client from '../ClientsPresence/models/Client'\nimport * as Immutable from 'immutable'\n\nexport type InstantSyncAuthPayload = {\n  auth_token: string\n}\n\ninterface IInstantSyncState {\n  requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  } | null\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: Client | null\n  localRecordsContents: OrderedMap<string, Record<string, any>>\n  localRecordsChanges: List<RecordChangeRequest>\n  stagedRecordsChanges: List<RecordChangeRequest>\n  localRecordsRev: number\n  requiredAttachmentIds: Set<string>\n  clients: Map<string, Client>\n}\n\n/**\n * InstantSyncState\n *\n * Describes current state of InstantSync\n */\n\nexport default class InstantSyncState extends Immutable.Record<IInstantSyncState>({\n  requestInfo: null,\n  status: 'offline',\n  currentClient: null,\n  localRecordsContents: OrderedMap(),\n  localRecordsChanges: List(),\n  stagedRecordsChanges: List(),\n  localRecordsRev: 0,\n  requiredAttachmentIds: Set(),\n  clients: Map(),\n}) {\n  /**\n   * Holds the endpoint URL (serverURL) and authentication token to make requests.\n   */\n  override requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   */\n  override status: 'offline' | 'connecting' | 'online'\n  override currentClient: Client\n\n  /**\n   * Holds a map of serialized object contents, which are in sync with the server and have no conflicts\n   */\n  override localRecordsContents: OrderedMap<string, Record<string, any>>\n\n  /**\n   * Holds a list for changes that have been made locally and have not yet been saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override localRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds a list for changes that have been made locally and are currently being saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override stagedRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds the latest revision of the `localRecordsContents`.\n   */\n  override localRecordsRev: number\n\n  /**\n   * All attachments ids, that need to be attached to the next request.\n   */\n  override requiredAttachmentIds: Set<string>\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   */\n  override clients: Map<string, Client>\n}\n","import { Class } from 'utility-types'\nimport { List } from 'immutable'\nimport { mergeChanges } from './utils'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport RecordChangeRequest from './RecordChangeRequest'\nimport InstantSyncCycle from './InstantSyncCycle'\nimport InstantSyncState from './InstantSyncState'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type { InstantSyncResponseChanges } from './InstantSyncCycle'\nimport type { IRecord } from './InstantProvider'\nimport { DEFAULT_LONG_POLLING_TIMEOUT } from './InstantSyncCycle'\nimport { debounceAsync } from '@/utils/debounce'\n\nexport default class InstantSync {\n  /************************\n   * Record operations\n   ************************/\n  getRecords(): List<IRecord> {\n    this._shouldFireRecordsUpdateCallback = true\n\n    return this._state.localRecordsContents\n      .map((record, id) => {\n        const { content, permissions, group } = record\n\n        return {\n          content,\n          permissions,\n          group,\n          id,\n        }\n      })\n      .toList()\n  }\n\n  createRecord(\n    id: string,\n    content: Record<string, any>,\n    attachments: Record<string, Blob>,\n    group?: string,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        attachments,\n        group,\n        type: 'created',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  updateRecord(\n    id: string,\n    content?: Record<string, any>,\n    group?: string,\n  ): Promise<Record<string, any>> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        group,\n        type: 'updated',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  deleteRecord(id: string): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        type: 'deleted',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  onRecordsUpdates(\n    recordsUpdateCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n    acceptedRecordsCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n  ) {\n    if (typeof recordsUpdateCallback !== 'function') {\n      throw new TypeError('recordsUpdateCallback must be a function')\n    }\n\n    if (typeof acceptedRecordsCallback !== 'function') {\n      throw new TypeError('acceptedRecordsCallback must be a function')\n    }\n\n    this._recordsUpdatesCallback = recordsUpdateCallback\n    this._acceptedRecordsResponseCallback = acceptedRecordsCallback\n  }\n\n  destroy() {\n    if (this._cycle) {\n      this._cycle.destroy()\n    }\n  }\n\n  /**************************\n   * Private Implementation *\n   **************************/\n  _state: InstantSyncState\n  _cycle: InstantSyncCycle\n  _CycleClass: Class<InstantSyncCycle>\n  _recordsUpdatesCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _acceptedRecordsResponseCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _shouldFireRecordsUpdateCallback = false\n\n  /**\n   * For easier testing, we allow a custom state and Cycle class in the constructor.\n   */\n  constructor(\n    state: InstantSyncState = new InstantSyncState(),\n    CycleClass: Class<InstantSyncCycle> = InstantSyncCycle,\n  ) {\n    this._state = state\n    this._CycleClass = CycleClass\n  }\n\n  /**\n   * This method should be called right after the constructor. See {@link InstantSync.load} for the\n   * public abstraction.\n   */\n  load(\n    serverURL: string,\n    authPayload: InstantSyncAuthPayload,\n    listenToServerChangesEnabled = true,\n  ): Promise<InstantSync> {\n    return new Promise((resolve, reject) => {\n      const getState = () => this._state\n\n      const setState = this.setState.bind(this)\n\n      this.setState(\n        this._state.set('requestInfo', {\n          serverURL,\n          authPayload,\n        }),\n      )\n      this._cycle = new this._CycleClass({\n        getState,\n        setState,\n        onChanges: this.onChanges,\n        onAcceptedRecords: this.onAcceptedRecords,\n        longPollingTimeout: listenToServerChangesEnabled ? DEFAULT_LONG_POLLING_TIMEOUT : 0,\n      })\n\n      // Executing the runCycle here also means that we will do the initial synchronization\n      // with the server and fetch the records.\n      this._cycle // We force a timeout of `0` here since we don't want the initial loading to have a delay\n        .nextCycle(0)\n        .then(() => {\n          resolve(this)\n        })\n        .catch(reject)\n    })\n  }\n\n  setState(newState: InstantSyncState): void {\n    this._state = newState\n  }\n\n  onChanges = (changes: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = changes\n\n      this._recordsUpdatesCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  onAcceptedRecords = (accepted: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = accepted\n\n      this._acceptedRecordsResponseCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  setOnDocumentHandleConflictCallback = (callback: () => void): void => {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this._cycle.setOnDocumentHandleConflictCallback(callback)\n  }\n\n  enqueueChangeRequest(changeRequest: RecordChangeRequest): void {\n    const mergedRecordsChanges = mergeChanges({\n      oldChanges: this._state.localRecordsChanges,\n      newChanges: List([changeRequest]),\n    })\n\n    this.setState(this._state.set('localRecordsChanges', mergedRecordsChanges))\n  }\n\n  /**\n   * Performs next sync cycle, pushing `localRecordsChanges` and pulling remote changes.\n   */\n  syncChanges: () => Promise<void> = debounceAsync(() => this._cycle.nextCycle())\n\n  isKnownRecordId(id: string): boolean {\n    function createdChangeWithSameId(change: RecordChangeRequest): boolean {\n      return change.type === 'created' && change.id === id\n    }\n\n    const isSyncedRecord = this._state.localRecordsContents.has(id)\n\n    const isLocalRecord = !!this._state.localRecordsChanges.find(createdChangeWithSameId)\n    const isStagedRecord = !!this._state.stagedRecordsChanges.find(createdChangeWithSameId)\n\n    return isSyncedRecord || isLocalRecord || isStagedRecord\n  }\n}\n","import { Annotation, Comment, FormField } from '../../models'\nimport type { State } from '../../models'\nimport type { IRecord } from './InstantProvider'\n\nexport function getRecordInState(\n  state: State,\n  record: IRecord,\n): Annotation | Comment | FormField | string | undefined {\n  const existingAnnotations = state.get('annotations')\n  const existingFormFields = state.get('formFields')\n  const existingComments = state.get('comments')\n  const existingFormFieldValues = state.get('formattedFormFieldValues')\n  let formFieldName\n\n  if (record.id.startsWith('form-field-value/')) {\n    formFieldName = record.id.split('/')[1]\n  }\n\n  return (\n    existingAnnotations.get(record.id) ||\n    existingFormFields.find(value => value.id === record.id) ||\n    existingComments.get(record.id) ||\n    (formFieldName ? existingFormFieldValues.get(formFieldName) : undefined)\n  )\n}\n\nexport function isRecordInState(state: State, record: IRecord): boolean {\n  return Boolean(getRecordInState(state, record))\n}\n","import { Class } from 'utility-types'\nimport { List, Map, Set } from 'immutable'\nimport { error, warn, PSPDFKitError, info, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  isBookmarkJSON,\n  isFormFieldJSON,\n  isFormFieldValueJSON,\n  serializeAnnotation,\n  attachmentsToObject,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeFormField,\n  serializeComment,\n  isCommentJSON,\n  deserializeComment,\n  isSignatureInfoJSON,\n  isEmbeddedFileJSON,\n} from '../serializers/utils'\nimport {\n  toJSON as serializeBookmark,\n  fromJSON as deserializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { CREATE_REASON_LOAD, CREATE_REASON_NEW } from '../Provider'\nimport ClientsPresence from '../ClientsPresence/ClientsPresence'\nimport InstantSync from './InstantSync'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { isRecordInState } from './collaboration-permissions'\nimport Annotation from '@/models/annotations/Annotation'\nimport Comment from '@/models/comments/Comment'\nimport FormField from '@/models/form-fields/FormField'\nimport { getRecordInState } from './collaboration-permissions'\nimport {\n  getCollaborationPermissionsFromJSON,\n  validateCollaborationPermissionJSON,\n} from '../serializers/collaboration-permissions'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { CreateReason } from '../Provider'\nimport { Attachment, Bookmark, WidgetAnnotation } from '@/models'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport { FormFieldValue, SignatureFormField } from '@/models/form-fields'\nimport type { FormFieldProvider, FormFieldProviderCallbacks } from '../FormFieldProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as AnnotationID } from '@/models/annotations/Annotation'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { ID as CommentID } from '@/models/comments/Comment'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type Client from '../ClientsPresence/models/Client'\nimport type { InstantID } from '@/models/InstantID'\nimport type { CommentProvider, CommentProviderCallbacks } from '../CommentProvider'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { State } from '@/models'\nimport { shouldShowSignatureFields } from '@/utils/permissions'\nimport { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\n\nexport type IRecord = {\n  id: string\n  content?: Record<string, any> | null\n  group?: string | null | undefined\n  permissions?: {\n    edit: boolean\n    delete: boolean\n    view: boolean\n    setGroup: boolean\n  }\n}\n\n/**\n * InstantProvider is an implementation of the AnnotationProvider that,\n * using the `/sync` endpoint, allows the client to sync with other devices and\n * benefit from server side conflict resolution.\n *\n * `createAnnotation` and `updateAnnotation` perform optimistic updates which are reverted\n * in case of conflicts with newer updates coming from the server.\n * `deleteAnnotation` instead is signed off only after the server has accepted the change\n * since in this case roll back and restore the annotation would be harder.\n */\nexport class InstantProvider\n  implements\n    ReadStateProvider,\n    AnnotationProvider,\n    BookmarkProvider,\n    FormFieldProvider,\n    FormFieldValueProvider,\n    CommentProvider\n{\n  _readStateCallbacks?: ReadStateProviderCallbacks\n  _annotationCallbacks?: AnnotationProviderCallbacks\n  _bookmarkCallbacks?: BookmarkProviderCallbacks\n  _formFieldCallbacks?: FormFieldProviderCallbacks\n  _formFieldValueCallbacks?: FormFieldValueCallbacks\n  _commentCallbacks?: CommentProviderCallbacks\n  // We keep track of the bookmarks IDs when we create new bookmarks\n  // because Instant sends a List of IDs when some deletion occurred.\n  // In such cases we can use this list to determine whether we are dealing with\n  // a bookmarks or annotation deletion.\n  _existingBookmarksIds: Set<BookmarkID> = Set()\n  _existingFormFieldsIds: Set<AnnotationID> = Set()\n  _existingFormFieldValuesIds: Set<string> = Set()\n  _existingCommentIds: Set<InstantID> = Set()\n  _sync: InstantSync\n  _clients?: ClientsPresence\n  _documentURL: string\n  _serverURL: string\n  _settings: InstantSettings\n  _authPayload: InstantSyncAuthPayload\n  _hasLoadedInitialRecords: boolean\n  _loadPromise: Promise<void> | null | undefined\n  _getState: () => State\n  _formsEnabledInConfig: boolean\n  onClientsChangeCallback: (...args: Array<any>) => any\n  _documentHandleConflictCallback: () => void = () => {}\n  _setDocumentHandleOutdatedCallback: (arg0: boolean) => void\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    documentURL: string,\n    authPayload: InstantSyncAuthPayload,\n    settings: InstantSettings = defaultInstantSettings,\n  ) {\n    this._serverURL = serverURL\n    this._documentURL = documentURL\n    this._authPayload = authPayload\n    this._settings = settings\n    this._hasLoadedInitialRecords = false\n  }\n\n  load(\n    SyncClass: Class<InstantSync> = InstantSync,\n    ClientsPresenceClass: Class<ClientsPresence> = ClientsPresence,\n  ): Promise<InstantProvider> {\n    const initializationPromises: Promise<any>[] = []\n\n    // Initialize sync.\n    this._sync = new SyncClass()\n    initializationPromises.push(\n      this._sync\n        .load(\n          `${this._documentURL}/sync`,\n          this._authPayload,\n          this._settings.listenToServerChangesEnabled,\n        )\n        .catch(error),\n    )\n\n    this._sync.setOnDocumentHandleConflictCallback(this.onDocumentHandleConflict)\n\n    if (this._settings.clientsPresenceEnabled) {\n      // Initialize clients presence.\n      this._clients = new ClientsPresenceClass()\n      initializationPromises.push(\n        this._clients\n          .load(`${this._serverURL.replace(/^http/i, 'ws')}/websocket`, this._authPayload, {})\n          .then(() => {\n            const clients = this._clients\n\n            if (clients == null) return\n\n            // Register callback\n            clients.onClientUpdates(() => this._onClientsChange(clients.getClients()))\n\n            // Handle initial clients the same way as a clients updates callback\n            this._onClientsChange(clients.getClients())\n          })\n          .catch(error => {\n            warn(\n              'PSPDFKit: An error occurred while initializing the connected clients module. ' +\n                'This might be due to a lack of support for WebSockets or a related failure.\\n\\n' +\n                'Failure details:\\n\\n' +\n                error.message,\n            )\n          }),\n      )\n    }\n\n    return Promise.all(initializationPromises)\n      .then(() => {\n        return this\n      })\n      .catch(error => {\n        throw new PSPDFKitError(`Initialization of PSPDFKit Instant failed:\n${error.message}`)\n      })\n  }\n\n  destroy() {\n    if (this._sync) {\n      this._sync.destroy()\n    }\n  }\n\n  setFormsEnabledInConfig(formsEnabledInConfig: boolean) {\n    this._formsEnabledInConfig = formsEnabledInConfig\n  }\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this._annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this._bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldCallbacks(formFieldCallbacks: FormFieldProviderCallbacks) {\n    this._formFieldCallbacks = formFieldCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this._formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  setCommentCallbacks(commentCallbacks: CommentProviderCallbacks) {\n    this._commentCallbacks = commentCallbacks\n  }\n\n  createAnnotation(annotation: Annotation, attachments: Map<string, Attachment>): Promise<void> {\n    const { id, ...data } = serializeAnnotation(annotation)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    return this._sync.createRecord(id, content, attachmentsToObject(attachments), group)\n  }\n\n  createComment(comment: Comment): Promise<void> {\n    const { id, ...data } = serializeComment(comment)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingCommentIds = this._existingCommentIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateComment(comment: Comment): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeComment(comment))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteComment(commentId: InstantID): Promise<void> {\n    this._existingCommentIds = this._existingCommentIds.delete(commentId)\n\n    return this._sync.deleteRecord(commentId).then(() => {})\n  }\n\n  setStateGetter(getState: () => State): void {\n    this._getState = getState\n  }\n\n  async updateRecord(data: Record<string, any>): Promise<Record<string, any>> {\n    const { id, permissions, group, ...content } = data\n\n    if (\n      this._getState &&\n      this._getState() &&\n      this._getState().backend?.isCollaborationPermissionsEnabled()\n    ) {\n      return this._sync.updateRecord(\n        id,\n        permissions.edit ? content : undefined,\n        permissions.setGroup ? group : undefined,\n      )\n    } else {\n      return this._sync.updateRecord(id, content, group)\n    }\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeAnnotation(annotation))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteAnnotation(annotation: Annotation): Promise<void> {\n    return this._sync.deleteRecord(annotation.id).then(() => {})\n  }\n\n  createBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(id, content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    return this._sync.deleteRecord(bookmarkId).then(() => {\n      this._existingBookmarksIds = this._existingBookmarksIds.delete(bookmarkId)\n    })\n  }\n\n  createFormField(formField: FormField): Promise<void> {\n    const { id, ...data } = serializeFormField(formField)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateFormField(formField: FormField): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeFormField(formField))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormField(formField: FormField): Promise<void> {\n    return this._sync.deleteRecord(formField.id).then(() => {\n      this._existingFormFieldsIds = this._existingFormFieldsIds.delete(formField.id)\n    })\n  }\n\n  // Form fields are retrieved in the annotations list\n  loadFormFields(): Promise<void> {\n    return this.loadAnnotationsForPageIndex()\n  }\n\n  createFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n    const id = getFormFieldValueID(formFieldValue)\n\n    this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(getFormFieldValueID(formFieldValue), content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormFieldValue(id: string): Promise<void> {\n    return this._sync.deleteRecord(id).then(() => {\n      this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n    })\n  }\n\n  loadAnnotationsForPageIndex(): Promise<void> {\n    // We only ever start listening to real time changes and emit events when\n    // the first page loading was initiated. This will make the behavior of the\n    // Instant annotation provider similar to what we do on the others (where we\n    // do not pre-download all annotations). This is necessary because we might\n    // not handle some callbacks before that.\n    //\n    // This also has impact on JavaScript support. We now load form fields the\n    // same way as annotations when the form designer feature is present which\n    // means form fields will not be present until the first pages have been\n    // loaded. JavaScript however might interpret document level scripts before\n    // that which will cause warnings when form fields are not initialized. See\n    // comment in connect.js before calling applyJavaScriptActionChanges.\n    //\n    // @FIXME(philipp): We need to clean that up and find a way to avoid the\n    // push to the next macro queue.\n    if (this._loadPromise) {\n      return this._loadPromise\n    }\n\n    this._loadPromise = new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n      if (!this._hasLoadedInitialRecords) {\n        // Register callback\n        this._sync.onRecordsUpdates(\n          // @ts-expect-error\n\n          (c, u, d) => this._onRecordsUpdates(c, u, d, CREATE_REASON_NEW),\n          // @ts-expect-error\n          (c, u, d) => this._onAcceptedRecords(c, u, d),\n        )\n\n        // Handle initial annotations list the same way as an annotations updates callback\n        this._onRecordsUpdates(this._sync.getRecords(), List(), List(), CREATE_REASON_LOAD)\n\n        this._hasLoadedInitialRecords = true\n      }\n    })\n\n    return this._loadPromise\n  }\n\n  async loadBookmarks(): Promise<void> {\n    return\n  }\n\n  syncChanges(): Promise<void> {\n    return this._sync.syncChanges()\n  }\n\n  /**\n   * In a situation where the user has set `disableForms: true` in the configuration,\n   * we don't set `this._formFieldCallbacks` and `this._formsEnabledInConfig` is set to `false` but the server doesn't know that and keeps\n   * sending the record updates for widgets. In that case we need to filter and remove\n   * the record that are widgets if `this.__formsEnabledInConfig` is set to `false`.\n   * @param records\n   * @private\n   */\n  _filterRecords(records: List<IRecord>): List<IRecord> {\n    // @ts-expect-error\n    return records.filter(({ content }) => this._formsEnabledInConfig || !isFormFieldJSON(content))\n  }\n\n  /******************************\n   * Internal Callback Handlers *\n   ******************************/\n  _onRecordsUpdates(\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n    createReason: CreateReason,\n  ) {\n    let mutableBookmarkAdditions: List<Bookmark> = List()\n    const mutableFormFieldAdditions: Array<FormField> = []\n    let mutableFormFieldValueAdditions: List<FormFieldValue> = List()\n    let mutableCommentAdditions: List<Comment> = List()\n    let deletions = Set() // we also remove updated annotations that encountered an error during deserializing\n\n    let bookmarkDeletions = Set() // we also remove updated bookmarks that encountered an error during deserializing\n\n    let formFieldDeletions = Set() // we also remove updated form fields that encountered an error during deserializing\n\n    let formFieldValueDeletions = Set() // we also remove updated form field values that encountered an error during deserializing\n\n    let commentDeletions = Set()\n    const state = this._getState ? this._getState() : undefined\n    let _created = created\n    let _updated = updated\n    let _deleted = deleted\n\n    if (state && state.backend && state.backend.isCollaborationPermissionsEnabled()) {\n      _created = _created.filter(({ content }) => !!content)\n\n      const updatesIndexToBeRemoved: number[] = []\n\n      updated.forEach((record, index) => {\n        if (!record.content) {\n          if (isRecordInState(state, record)) {\n            // If we receive a record with no content and it’s present in our store,\n            // it means it’s visibility permission was set to hidden and\n            // we delete the record from our store.\n            _deleted = _deleted.push(record.id)\n            updatesIndexToBeRemoved.push(index)\n          } else {\n            // If we receive a record with no content and it’s not present in our store, we do nothing.\n            updatesIndexToBeRemoved.push(index)\n          }\n        } else if (!isRecordInState(state, record)) {\n          // If we receive a record with content which isn’t present in our store, it means the visibility permission was changed.\n          // In that case, we will create a new record.\n          _created = _created.push(record)\n          updatesIndexToBeRemoved.push(index)\n        }\n      })\n      _updated = _updated.filter((_record, index) => !updatesIndexToBeRemoved.includes(index))\n      _deleted = _deleted.filter(\n        d =>\n          state.annotations.has(d) ||\n          this._existingFormFieldValuesIds.has(d) ||\n          this._existingFormFieldsIds.has(d) ||\n          this._existingCommentIds.has(d) ||\n          this._existingBookmarksIds.has(d),\n      )\n    }\n\n    let additions = List().withMutations(mutableAdditions => {\n      this._filterRecords(_created).forEach(({ id, content, permissions, group }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            // @ts-expect-error\n            mutableFormFieldAdditions.push(deserializeFormField(id, content, options))\n            this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.push(\n              // @ts-expect-error\n              deserializeFormFieldValue(content),\n            )\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            // TODO figure out why when I use mutableBookmarkAdditions asMutable() push produces a list of IDs only 🤷‍♂️\n            mutableBookmarkAdditions = mutableBookmarkAdditions.push(\n              // @ts-expect-error\n              deserializeBookmark(id, content),\n            )\n            this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            this._existingCommentIds = this._existingCommentIds.add(id)\n            mutableCommentAdditions = mutableCommentAdditions.push(\n              // @ts-expect-error\n              deserializeComment(id, content, options),\n            )\n            // @ts-expect-error\n          } else if (isSignatureInfoJSON(content)) {\n            // No-op on digital signatures changes since we won't be syncing signatures\n            // on real-time\n            // @ts-expect-error\n          } else if (isEmbeddedFileJSON(content)) {\n            // No-op since web does not support embedded files yet.\n          } else {\n            // @ts-expect-error\n            mutableAdditions.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          info(\n            `Skipped creating record #${id} from payload because an error occurred while deserializing.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n    const showSignatures = state\n      ? shouldShowSignatureFields(\n          state.features,\n          state.signatureFeatureAvailability as ISignatureFeatureAvailability,\n        )\n      : true\n\n    if (mutableFormFieldAdditions.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      if (state && !showSignatures) {\n        // Although Server returns all form fields, if the needed license features\n        // combination is not given, we should avoid to add signature form fields.\n        // See https://docs.google.com/document/d/1ry0uJIGAgUPa6cmjCWCKRC5zReqdfpROuQyhOt7GXNs/edit#heading=h.dlbwh9b87wv3\n        this._formFieldCallbacks.createFormFields(\n          List(\n            mutableFormFieldAdditions.filter(\n              formField => !(formField instanceof SignatureFormField),\n            ),\n          ),\n          createReason,\n        )\n      } else {\n        this._formFieldCallbacks.createFormFields(List(mutableFormFieldAdditions), createReason)\n      }\n    }\n\n    if (additions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      if (state && !showSignatures) {\n        // Don't store widgets associated to ignored form fields on step above\n        additions = additions.filter(annotation => {\n          if (!(annotation instanceof WidgetAnnotation)) {\n            return annotation\n          }\n\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === annotation.formFieldName) ||\n            state.formFields.get(annotation.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._annotationCallbacks.createAnnotations(additions, Map(), createReason)\n    }\n\n    if (mutableFormFieldValueAdditions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      if (state && !showSignatures) {\n        // Take into account purposefully ignored form fields from step above\n        mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.filter(value => {\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === value.name) ||\n            // @ts-expect-error\n            state.formFields.get(value.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._formFieldValueCallbacks.createFormFieldValues(\n        List(mutableFormFieldValueAdditions),\n        createReason,\n      )\n    }\n\n    if (mutableCommentAdditions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.createComments(mutableCommentAdditions, createReason)\n    }\n\n    if (mutableBookmarkAdditions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.createBookmarks(mutableBookmarkAdditions, createReason)\n    }\n\n    const mutableBookmarkChanges: List<Bookmark> = List().asMutable()\n    const mutableFormFieldChanges: Array<FormField> = []\n    const mutableFormFieldValueChanges: Array<FormFieldValue> = []\n    const mutableCommentChanges: Array<Comment> = []\n    const updates = List().withMutations(mutableUpdates => {\n      this._filterRecords(_updated).forEach(({ id, content, group, permissions }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldChanges.push(deserializeFormField(id, content, options))\n            } catch (error) {\n              formFieldDeletions = formFieldDeletions.add(id)\n              info(\n                `Skipped updating form field #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldValueChanges.push(deserializeFormFieldValue(content))\n            } catch (error) {\n              formFieldValueDeletions = formFieldValueDeletions.add(id)\n              info(\n                `Skipped updating form field value #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableBookmarkChanges.push(deserializeBookmark(id, content))\n            } catch (error) {\n              bookmarkDeletions = bookmarkDeletions.add(id)\n              info(\n                `Skipped updating bookmark #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableCommentChanges.push(deserializeComment(id, content, options))\n            } catch (error) {\n              commentDeletions = commentDeletions.add(id)\n              info(\n                `Skipped updating comment #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n                error,\n              )\n            }\n          } else {\n            // @ts-expect-error\n            mutableUpdates.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          deletions = deletions.add(id)\n          info(\n            `Skipped updating annotation #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n\n    if (updates.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.updateAnnotations(updates)\n    }\n\n    if (mutableBookmarkChanges.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.updateBookmarks(mutableBookmarkChanges)\n    }\n\n    if (mutableFormFieldChanges.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(mutableFormFieldChanges))\n    }\n\n    if (mutableFormFieldValueChanges.length > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.setFormFieldValues(List(mutableFormFieldValueChanges))\n    }\n\n    if (mutableCommentChanges.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(mutableCommentChanges))\n    }\n\n    deletions = deletions.concat(\n      _deleted\n        .filter(\n          id =>\n            !this._existingBookmarksIds.has(id) &&\n            !this._existingFormFieldsIds.has(id) &&\n            !this._existingFormFieldValuesIds.has(id) &&\n            !this._existingCommentIds.has(id),\n        )\n        .toSet(),\n    )\n\n    if (deletions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.deleteAnnotations(deletions)\n    }\n\n    bookmarkDeletions = bookmarkDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isBookmarkDeletion = this._existingBookmarksIds.has(id)\n\n          if (isBookmarkDeletion) {\n            this._existingBookmarksIds = this._existingBookmarksIds.delete(id)\n          }\n\n          return isBookmarkDeletion\n        })\n        .toSet(),\n    )\n\n    if (bookmarkDeletions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.deleteBookmarks(bookmarkDeletions)\n    }\n\n    formFieldDeletions = formFieldDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldDeletion = this._existingFormFieldsIds.has(id)\n\n          if (isFormFieldDeletion) {\n            this._existingFormFieldsIds = this._existingFormFieldsIds.delete(id)\n          }\n\n          return isFormFieldDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldDeletions.size > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(formFieldDeletions)\n    }\n\n    formFieldValueDeletions = formFieldValueDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldValueDeletion = this._existingFormFieldValuesIds.has(id)\n\n          if (isFormFieldValueDeletion) {\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n          }\n\n          return isFormFieldValueDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldValueDeletions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.deleteFormFieldValues(formFieldValueDeletions)\n    }\n\n    commentDeletions = commentDeletions.concat(\n      _deleted\n        .filter(id => {\n          const commentDeletion = this._existingCommentIds.has(id)\n\n          if (commentDeletion) {\n            this._existingCommentIds = this._existingCommentIds.delete(id)\n          }\n\n          return commentDeletion\n        })\n        .toSet(),\n    )\n\n    if (commentDeletions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(commentDeletions)\n    }\n  }\n\n  _onAcceptedRecords(created: List<IRecord>, updated: List<IRecord>) {\n    const state = this._getState ? this._getState() : undefined\n\n    if (!state || !state.backend || !state.backend.isCollaborationPermissionsEnabled()) {\n      return\n    }\n\n    // When Collaboration Permissions are enabled we need to update the locally created or updated\n    // records so that they include the proper permissions enforced by the backend.\n    const annotationsUpdates: Array<Annotation> = []\n    const commentsUpdates: Array<Comment> = []\n    const formFieldsUpdates: Array<FormField> = []\n    // We also need to remove records from the Redux store if Server doesn't assign view\n    // permissions\n    const deletableAnnotations: Array<AnnotationID> = []\n    const deletableComments: Array<BookmarkID> = []\n    const deletableFormFields: Array<CommentID> = []\n\n    if (!created.isEmpty()) {\n      created.forEach(mergePermissionsOnRecords)\n    }\n\n    if (!updated.isEmpty()) {\n      updated.forEach(mergePermissionsOnRecords)\n    }\n\n    if (annotationsUpdates.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.updateAnnotations(List(annotationsUpdates), true)\n    }\n\n    if (commentsUpdates.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(commentsUpdates))\n    }\n\n    if (formFieldsUpdates.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(formFieldsUpdates))\n    }\n\n    if (deletableAnnotations.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.deleteAnnotations(Set(deletableAnnotations), true)\n    }\n\n    if (deletableComments.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(Set(deletableComments))\n    }\n\n    if (deletableFormFields.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(Set(deletableFormFields))\n    }\n\n    function mergePermissionsOnRecords(record: IRecord) {\n      const options = {\n        permissions: record.permissions,\n        group: record.group,\n      }\n      let entity = getRecordInState(state as State, record)\n\n      // We can ignore form field values responses (string type)\n      if (entity && typeof entity !== 'string') {\n        validateCollaborationPermissionJSON(options)\n\n        const collaborationPermissions = getCollaborationPermissionsFromJSON(options)\n\n        entity = entity.merge(collaborationPermissions)\n\n        if (entity instanceof Annotation) {\n          if (options.permissions && options.permissions.view) {\n            annotationsUpdates.push(entity)\n          } else {\n            deletableAnnotations.push(entity.id)\n          }\n        } else if (entity instanceof Comment) {\n          if (options.permissions && options.permissions.view) {\n            commentsUpdates.push(entity)\n          } else {\n            invariant(entity.id)\n            deletableComments.push(entity.id)\n          }\n        } else if (entity instanceof FormField) {\n          if (options.permissions && options.permissions.view) {\n            formFieldsUpdates.push(entity)\n          } else {\n            deletableFormFields.push(entity.id)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the on clients change callback. Will be overwritten when another callback is set.\n   */\n  onClientsChange(onClientsChangeCallback: (clients: Map<string, Client>) => void): void {\n    if (typeof onClientsChangeCallback !== 'function') {\n      throw new TypeError('Callback must be a function')\n    }\n\n    this.onClientsChangeCallback = onClientsChangeCallback\n  }\n\n  _onClientsChange(clients: Map<string, Client>): void {\n    this.onClientsChangeCallback.call(null, clients)\n  }\n\n  /**\n   * Document handle conflict callback handlers.\n   */\n\n  /**\n   * Set by ServerBackend after instantiating the provider\n   */\n  setDocumentHandleConflictCallback = (callback: () => void) => {\n    this._documentHandleConflictCallback = callback\n  }\n\n  /**\n   * Set in utils/document by setupManagers() on connect and reconnect\n   */\n  setDocumentHandleOutdated = (callback: (arg0: boolean) => void) => {\n    this._setDocumentHandleOutdatedCallback = callback\n  }\n\n  /**\n   * Callback passed to InstantSync when instantiating it\n   */\n  onDocumentHandleConflict = () => {\n    this._documentHandleConflictCallback && this._documentHandleConflictCallback()\n    this._setDocumentHandleOutdatedCallback && this._setDocumentHandleOutdatedCallback(true)\n  }\n}\n"],"names":["Client","Immutable","clientId","userId","presenceContent","ClientsPresenceState","status","currentClient","clients","Map","Timer","constructor","callback","timerCalc","this","timer","tries","reset","clearTimeout","scheduleTimeout","setTimeout","CLIENT_VERSION","SOCKET_STATES","CLIENT_INFO","name","defaultReconnectTimerCalc","n","WebsocketConnection","serverURL","authPayload","reconnectTimerCalc","enableReconnect","events","eventEmitter","EventEmitter","concat","socket","lastRequestId","requestsWaitingForAnswers","reconnectTimer","close","connect","clearAuthenticationInformation","registerEvents","push","WebSocket","onopen","onOpen","bind","onmessage","onMessage","onerror","emit","disconnect","onclose","abortOpenRequests","readyState","sendRequest","action","payload","Promise","resolve","reject","isAuthenticated","PSPDFKitError","requestId","nextRequestId","serializedPayload","JSON","stringify","set","send","on","off","onError","onClose","message","data","frame","parseFrame","invariant","has","request","get","reason","delete","includes","log","parseUnauthenticatedFrame","onHello","onAuthenticated","event","error","protocol_version","requestPayload","client_version","client_info","auth_payload","client_id","user_id","getEnvironment","args","console","requestIdOrInfo","exec","toString","parseInt","parse","forEach","clientFromPayload","presence","ClientsPresence","state","connectionClass","load","initialPresenceContent","setState","newState","connection","session","populateClients","then","catch","onInfoClientPresence","withMutations","mutableState","map","clientPayload","c","setClientsAction","newClients","mutableClients","entered","client","updated","left","applyClientChangesAction","shouldFireClientUpdatesCallback","enteredClientIds","filter","indexOf","toMap","updatedClientIds","List","clientUpdatesCallback","getStatus","getCurrentClient","getClients","updatePresence","setIn","updateCurrentClientPresenceAction","onClientUpdates","TypeError","RecordChangeRequest","content","attachments","id","type","group","undefined","InstantSyncState","requestInfo","localRecordsContents","OrderedMap","localRecordsChanges","stagedRecordsChanges","localRecordsRev","requiredAttachmentIds","Set","InstantSync","getRecords","_shouldFireRecordsUpdateCallback","_state","record","permissions","toList","createRecord","change","enqueueChangeRequest","updateRecord","isKnownRecordId","deleteRecord","onRecordsUpdates","recordsUpdateCallback","acceptedRecordsCallback","_recordsUpdatesCallback","_acceptedRecordsResponseCallback","destroy","_cycle","CycleClass","InstantSyncCycle","_CycleClass","listenToServerChangesEnabled","getState","onChanges","onAcceptedRecords","longPollingTimeout","DEFAULT_LONG_POLLING_TIMEOUT","nextCycle","changes","created","deleted","accepted","setOnDocumentHandleConflictCallback","changeRequest","mergedRecordsChanges","mergeChanges","oldChanges","newChanges","syncChanges","debounceAsync","createdChangeWithSameId","isSyncedRecord","isLocalRecord","find","isStagedRecord","getRecordInState","existingAnnotations","existingFormFields","existingComments","existingFormFieldValues","formFieldName","startsWith","split","value","isRecordInState","Boolean","InstantProvider","_existingBookmarksIds","_existingFormFieldsIds","_existingFormFieldValuesIds","_existingCommentIds","_documentHandleConflictCallback","canCreateBackendOrphanWidgets","documentURL","settings","defaultInstantSettings","_serverURL","_documentURL","_authPayload","_settings","_hasLoadedInitialRecords","SyncClass","ClientsPresenceClass","initializationPromises","_sync","onDocumentHandleConflict","clientsPresenceEnabled","_clients","replace","_onClientsChange","warn","all","setFormsEnabledInConfig","formsEnabledInConfig","_formsEnabledInConfig","setReadStateCallbacks","readStateCallbacks","_readStateCallbacks","setAnnotationCallbacks","annotationCallbacks","_annotationCallbacks","setBookmarkCallbacks","bookmarkCallbacks","_bookmarkCallbacks","setFormFieldCallbacks","formFieldCallbacks","_formFieldCallbacks","setFormFieldValueCallbacks","formFieldValueCallbacks","_formFieldValueCallbacks","setCommentCallbacks","commentCallbacks","_commentCallbacks","createAnnotation","annotation","serializeAnnotation","attachmentsToObject","createComment","comment","serializeComment","add","e","deleteComment","commentId","setStateGetter","_getState","backend","isCollaborationPermissionsEnabled","edit","setGroup","deleteAnnotation","createBookmark","bookmark","serializeBookmark","deleteBookmark","bookmarkId","createFormField","formField","serializeFormField","deleteFormField","loadFormFields","loadAnnotationsForPageIndex","createFormFieldValue","formFieldValue","serializeFormFieldValue","getFormFieldValueID","deleteFormFieldValue","_loadPromise","u","d","_onRecordsUpdates","CREATE_REASON_NEW","_onAcceptedRecords","CREATE_REASON_LOAD","_filterRecords","records","isFormFieldJSON","createReason","mutableBookmarkAdditions","mutableFormFieldAdditions","mutableFormFieldValueAdditions","mutableCommentAdditions","deletions","bookmarkDeletions","formFieldDeletions","formFieldValueDeletions","commentDeletions","_created","_updated","_deleted","updatesIndexToBeRemoved","index","_record","annotations","additions","mutableAdditions","options","deserializeFormField","isFormFieldValueJSON","deserializeFormFieldValue","isBookmarkJSON","deserializeBookmark","isCommentJSON","deserializeComment","isSignatureInfoJSON","isEmbeddedFileJSON","deserializeAnnotation","info","showSignatures","shouldShowSignatureFields","features","signatureFeatureAvailability","length","createFormFields","SignatureFormField","size","WidgetAnnotation","field","formFields","createAnnotations","createFormFieldValues","createComments","createBookmarks","mutableBookmarkChanges","asMutable","mutableFormFieldChanges","mutableFormFieldValueChanges","mutableCommentChanges","updates","mutableUpdates","updateAnnotations","updateBookmarks","updateFormFields","setFormFieldValues","updateComments","toSet","deleteAnnotations","isBookmarkDeletion","deleteBookmarks","isFormFieldDeletion","deleteFormFields","isFormFieldValueDeletion","deleteFormFieldValues","commentDeletion","deleteComments","annotationsUpdates","commentsUpdates","formFieldsUpdates","deletableAnnotations","deletableComments","deletableFormFields","mergePermissionsOnRecords","entity","validateCollaborationPermissionJSON","collaborationPermissions","getCollaborationPermissionsFromJSON","merge","Annotation","view","Comment","FormField","isEmpty","onClientsChange","onClientsChangeCallback","call","setDocumentHandleConflictCallback","setDocumentHandleOutdated","_setDocumentHandleOutdatedCallback"],"sourceRoot":""}