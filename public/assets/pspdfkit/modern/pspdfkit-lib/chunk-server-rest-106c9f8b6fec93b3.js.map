{"version":3,"file":"modern/pspdfkit-lib/chunk-server-rest-106c9f8b6fec93b3.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/RESTProvider/RESTProviderState.ts","webpack://PSPDFKit/./src/lib/RESTProvider/RESTProvider.ts"],"sourcesContent":["import { List, Map } from 'immutable'\nimport * as Immutable from 'immutable'\n\ninterface IRESTProviderState {\n  alreadyLoadedPages: Map<number, Promise<void>>\n  serverURL: string | null\n  authPayload: {\n    token: string\n  } | null\n  isLoaded: boolean\n  isFormsEnabled: boolean\n  loadBookmarksPromise: Promise<void> | null | undefined\n  ignoredFormFieldNames?: List<string> | null\n}\n\nexport class RESTProviderState extends Immutable.Record<IRESTProviderState>({\n  alreadyLoadedPages: Map(),\n  serverURL: null,\n  authPayload: null,\n  isLoaded: false,\n  isFormsEnabled: true,\n  loadBookmarksPromise: null,\n  ignoredFormFieldNames: null,\n}) {\n  /**\n   * Used to remember which page annotations have already been loaded.\n   *\n   * @member {Immutable.Map.<number, Promise.<void>>} alreadyLoadedPages\n   */\n  override alreadyLoadedPages: Map<number, Promise<void>>\n\n  /**\n   * @member {string} serverURL\n   */\n  override serverURL: string\n\n  /**\n   * @member {Object} authPayload\n   */\n  override authPayload: {\n    token: string\n  }\n  override isLoaded: boolean\n  override isFormsEnabled: boolean\n\n  /**\n   * Used to fire loadBookmarks only once.\n   *\n   * @member {?Promise.<void>} loadBookmarksPromise\n   */\n  override loadBookmarksPromise: Promise<void> | null | undefined\n\n  /**\n   * Used to know which form field values can be omitted safely.\n   *\n   * @member {?List.<string>} ignoredFormFieldNames\n   */\n  override ignoredFormFieldNames?: List<string>\n}\n","import { List, Map } from 'immutable'\nimport { info, PSPDFKitError, error } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  serializeAnnotation,\n  serializeFormFieldValue,\n} from '../serializers/utils'\nimport {\n  fromJSON as deserializeBookmark,\n  toJSON as serializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { RESTProviderState } from './RESTProviderState'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { CREATE_REASON_LOAD } from '../Provider'\nimport type { Annotation, Attachment, Bookmark, FormFieldValue } from '../../models'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as BookmarkID } from '../../models/Bookmark'\nimport { invariant } from '../../utils/invariant'\nimport { IObject } from '../../typings/utils'\nimport { getVersionHeader } from '@/utils/environment'\n\n/**\n * A REST interface to annotation loading. It can't handle real time update and will fetch\n * annotations per-page.\n *\n * @todo How do we handle errors?\n */\nexport class RESTProvider\n  implements ReadStateProvider, AnnotationProvider, BookmarkProvider, FormFieldValueProvider\n{\n  _readStateCallbacks: ReadStateProviderCallbacks | null | undefined\n  annotationCallbacks: AnnotationProviderCallbacks | null | undefined\n  bookmarkCallbacks: BookmarkProviderCallbacks | null | undefined\n  formFieldValueCallbacks: FormFieldValueCallbacks | null | undefined\n  state: RESTProviderState\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    authPayload: {\n      token: string\n    },\n    {\n      isFormsEnabled,\n    }: {\n      isFormsEnabled: boolean\n    },\n  ) {\n    this.state = new RESTProviderState({\n      serverURL,\n      authPayload,\n      isFormsEnabled,\n    })\n  }\n\n  /*************************\n   * Connection management *\n   *************************/\n  async load(): Promise<RESTProvider> {\n    this.state = this.state.set('isLoaded', true)\n\n    if (this.state.isFormsEnabled) {\n      // Form Field Values are not loaded on a per-page basis. Thus, we fetch them all in here\n      await this._initializeFormFieldValues()\n    }\n\n    return this\n  }\n\n  destroy(): void {}\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this.annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this.bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this.formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  /******************\n   * Annotation API *\n   ******************/\n  async createAnnotation(\n    annotation: Annotation,\n    attachments: Map<string, Attachment>,\n  ): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n    const annotationBody = {\n      id,\n      content,\n    }\n\n    await this._request('/annotations', 'POST', annotationBody).then(r => {\n      if (r.status !== 200) {\n        throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an annotation.')\n      }\n\n      r.json().then(json => {\n        if (json.error === 'attachment_missing') {\n          // When the attachment is not already stored on the server, we need to attach the\n          // attachments to the request\n          const newBody = createFormData(annotationBody, attachments)\n\n          return this._request('/annotations', 'POST', newBody).then(r => r.json())\n        }\n\n        return json\n      })\n    })\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    await this._request(`/annotations/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    await this._request(`/annotations/${annotation.id}`, 'DELETE')\n  }\n\n  /******************\n   * Bookmark API *\n   ******************/\n  async createBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n    const response = await this._request('/bookmarks', 'POST', {\n      id,\n      content,\n    })\n\n    if (response.status !== 200) {\n      throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an bookmark.')\n    }\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    await this._request(`/bookmarks/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n    await this._request(`/bookmarks/${bookmarkId}`, 'DELETE')\n  }\n\n  /******************\n   * FormFieldValue API *\n   ******************/\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    this._verifyLoaded()\n\n    const payload = {\n      id: getFormFieldValueID(formFieldValue),\n      content: serializeFormFieldValue(formFieldValue),\n    }\n\n    await this._request('/form-field-values', 'POST', {\n      formFieldValues: [payload],\n    })\n  }\n\n  // Stub to be implemented when this provider is supported\n  async createFormFieldValue(): Promise<void> {\n    return\n  }\n\n  // Stub to be implemented when this provider is supported\n  async deleteFormFieldValue(): Promise<void> {\n    return\n  }\n\n  async loadAnnotationsForPageIndex(pageIndex: number): Promise<void> {\n    this._verifyLoaded()\n\n    if (this.state.alreadyLoadedPages.has(pageIndex)) {\n      await this.state.alreadyLoadedPages.get(pageIndex)\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request(`/page-${pageIndex}-annotations`, 'GET')\n        .then(response => response.json())\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadAnnotationsForPageIndex` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], Promise.resolve())\n\n      const additions = List().withMutations(mutableAdditions => {\n        payload.annotations.forEach(record => {\n          try {\n            mutableAdditions.push(deserializeAnnotation(record.id, record.content))\n          } catch (error) {\n            info(\n              `Skipped creating annotation #${record.id} from payload because an error occurred while deserializing.`,\n              record.content,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (additions.size > 0) {\n        invariant(this.annotationCallbacks)\n        this.annotationCallbacks.createAnnotations(additions, Map(), CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'annotations')\n    }\n  }\n\n  async loadBookmarks() {\n    this._verifyLoaded()\n\n    if (this.state.loadBookmarksPromise) {\n      await this.state.loadBookmarksPromise\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request('/bookmarks', 'GET')\n        .then(response => response.json())\n        .then(payload => payload.data)\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadBookmarks` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.set('loadBookmarksPromise', payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.set('loadBookmarksPromise', Promise.resolve())\n      invariant(Array.isArray(payload.bookmarks), 'Unexpected reply from bookmarks endpoint.')\n\n      const bookmarks = List().withMutations(mutableBookmarks => {\n        payload.bookmarks.forEach((json: Record<string, any>) => {\n          try {\n            mutableBookmarks.push(deserializeBookmark(json.id, json.content))\n          } catch (error) {\n            info(\n              `Skipped creating bookmark #${json.id} from payload because an error occurred while deserializing.`,\n              // @ts-expect-error\n              json,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (bookmarks.size > 0) {\n        invariant(this.bookmarkCallbacks)\n        this.bookmarkCallbacks.createBookmarks(bookmarks, CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'bookmarks')\n    }\n  }\n\n  async syncChanges(): Promise<void> {}\n\n  async _initializeFormFieldValues(): Promise<void> {\n    const request = await this._request('/form-field-values', 'GET')\n    const response = await request.json()\n\n    invariant(\n      Array.isArray(response.formFieldValues),\n      'Unexpected reply from form-values endpoint.',\n    )\n\n    const formFieldValues = List<FormFieldValue>(\n      response.formFieldValues\n        .map(({ content: formFieldValueJSON }) => {\n          try {\n            return deserializeFormFieldValue(formFieldValueJSON)\n          } catch (error) {\n            info(\n              `Skipped form field value ${formFieldValueJSON.name} from payload because an error occurred while deserializing.`,\n              formFieldValueJSON,\n            )\n            info(error)\n\n            return null\n          }\n        })\n        .filter(Boolean),\n    )\n\n    invariant(this.formFieldValueCallbacks)\n\n    if (this.state.ignoredFormFieldNames && this.state.ignoredFormFieldNames.size) {\n      this.formFieldValueCallbacks.setFormFieldValues(\n        formFieldValues.filter(value => !this.state.ignoredFormFieldNames?.includes(value.name)),\n      )\n    } else {\n      this.formFieldValueCallbacks.setFormFieldValues(formFieldValues)\n    }\n  }\n\n  _handleError(e: Error, type: 'annotations' | 'bookmarks') {\n    error(`Loading or updating ${type} failed:\n\n${e.message}`)\n  }\n\n  _request(\n    path: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    body?: IObject,\n  ): Promise<IObject> {\n    invariant(this.state.authPayload != null, 'Cannot call request without authPayload')\n\n    const contentTypeHeader =\n      !(body instanceof FormData) && typeof body === 'object'\n        ? {\n            'Content-Type': 'application/json',\n          }\n        : null\n    const headers = {\n      'X-PSPDFKit-Token': this.state.authPayload.token,\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n      ...contentTypeHeader,\n    }\n\n    return fetch(`${this.state.serverURL}${path}`, {\n      method,\n      headers,\n      body:\n        body instanceof FormData\n          ? body\n          : typeof body === 'object'\n          ? JSON.stringify(body)\n          : undefined,\n      credentials: 'include',\n    })\n  }\n\n  _verifyLoaded() {\n    if (!this.state.isLoaded) {\n      throw new Error('not loaded')\n    }\n  }\n\n  setDocumentHandleConflictCallback = () => {}\n\n  setIgnoredFormFieldNames(formFields: List<string>) {\n    this.state = this.state.set('ignoredFormFieldNames', formFields)\n  }\n}\n\nfunction createFormData(annotationBody, attachments) {\n  const formData = new FormData()\n\n  formData.append('annotation', JSON.stringify(annotationBody))\n  attachments.forEach((attachment, attachmentId) => {\n    if (attachmentId && attachment.data) {\n      formData.append(attachmentId, attachment.data)\n    }\n  })\n\n  return formData\n}\n"],"names":["RESTProviderState","Immutable","alreadyLoadedPages","Map","serverURL","authPayload","isLoaded","isFormsEnabled","loadBookmarksPromise","ignoredFormFieldNames","RESTProvider","canCreateBackendOrphanWidgets","constructor","this","state","set","_initializeFormFieldValues","destroy","setReadStateCallbacks","readStateCallbacks","_readStateCallbacks","setAnnotationCallbacks","annotationCallbacks","setBookmarkCallbacks","bookmarkCallbacks","setFormFieldValueCallbacks","formFieldValueCallbacks","annotation","attachments","_verifyLoaded","id","content","serializeAnnotation","annotationBody","_request","then","r","status","PSPDFKitError","json","error","newBody","formData","FormData","append","JSON","stringify","forEach","attachment","attachmentId","data","createFormData","bookmark","loadBookmarks","serializeBookmark","bookmarkId","formFieldValue","payload","getFormFieldValueID","serializeFormFieldValue","formFieldValues","pageIndex","has","get","payloadPromise","response","catch","setIn","Promise","resolve","additions","List","withMutations","mutableAdditions","annotations","record","push","deserializeAnnotation","info","size","invariant","createAnnotations","CREATE_REASON_LOAD","_handleError","Array","isArray","bookmarks","mutableBookmarks","deserializeBookmark","createBookmarks","request","map","formFieldValueJSON","deserializeFormFieldValue","name","filter","Boolean","setFormFieldValues","value","includes","e","type","message","path","method","body","contentTypeHeader","headers","token","getVersionHeader","fetch","undefined","credentials","Error","setDocumentHandleConflictCallback","setIgnoredFormFieldNames","formFields"],"sourceRoot":""}